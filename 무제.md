## 채팅 기록

[](https://chatgpt.com/)

##### 나의 말:

코드 이해부터 하자 1. 백엔드 코드를 먼저 보여줄게 파일구조랑 2. 프론트 코드랑 파일구조를 보여줄게 3. 내가 에러를 보여줄테니 어떤게 문제인지 해결해서 전체 코드를 보여줘

###### ChatGPT의 말:

네, 알겠습니다. 먼저 백엔드 코드와 파일 구조를 공유해 주시면, 자세히 살펴보겠습니다.

##### 나의 말:

# 
Backend/models/file.py from sqlalchemy import Column, Integer, String, ForeignKey, TIMESTAMP, text from .base import Base class File(Base): __tablename__ = 'file' id = Column(Integer, primary_key=True, autoincrement=True) user_id = Column(Integer, ForeignKey('user.u_id', ondelete='CASCADE'), nullable=False) folder_id = Column(Integer, ForeignKey('folder.id', ondelete='SET NULL'), nullable=True) original_name = Column(String(255), nullable=False) # 유저가 업로드한 원본 파일 이름 saved_path = Column(String(512), nullable=False) # 서버에 저장된(실제) 경로 content_type = Column(String(100), nullable=False) # MIME 타입 created_at = Column(TIMESTAMP, nullable=False, server_default=text('CURRENT_TIMESTAMP')) from sqlalchemy import Column, Integer, String, ForeignKey, TIMESTAMP, text from .base import Base class Folder(Base): __tablename__ = 'folder' id = Column(Integer, primary_key=True, autoincrement=True) user_id = Column(Integer, ForeignKey('user.u_id', ondelete='CASCADE'), nullable=False) name = Column(String(100), nullable=False) parent_id = Column(Integer, ForeignKey('folder.id', ondelete='SET NULL'), nullable=True) created_at = Column(TIMESTAMP, nullable=False, server_default=text('CURRENT_TIMESTAMP')) updated_at = Column(TIMESTAMP, nullable=False, server_default=text('CURRENT_TIMESTAMP'), onupdate=text('CURRENT_TIMESTAMP')) from sqlalchemy import Column, Integer, String, Text, Boolean, ForeignKey, TIMESTAMP, text from .base import Base class Note(Base): __tablename__ = 'note' id = Column(Integer, primary_key=True, autoincrement=True) user_id = Column(Integer, ForeignKey('user.u_id', ondelete='CASCADE'), nullable=False) folder_id = Column(Integer, ForeignKey('folder.id', ondelete='SET NULL'), nullable=True) title = Column(String(255), nullable=False) content = Column(Text) is_favorite = Column(Boolean, nullable=False, server_default=text('FALSE')) last_accessed = Column(TIMESTAMP, nullable=True) created_at = Column(TIMESTAMP, nullable=False, server_default=text('CURRENT_TIMESTAMP')) updated_at = Column(TIMESTAMP, nullable=False, server_default=text('CURRENT_TIMESTAMP'), onupdate=text('CURRENT_TIMESTAMP')) from sqlalchemy import Column, Integer, String, Enum, TIMESTAMP, text from .base import Base class User(Base): __tablename__ = 'user' u_id = Column(Integer, primary_key=True, autoincrement=True) id = Column(String(50), nullable=False, unique=True) email = Column(String(150), nullable=False, unique=True) password = Column(String(255), nullable=False) provider = Column( Enum('local','google','kakao','naver', name='provider_enum'), nullable=False, server_default=text("'local'") ) created_at = Column(TIMESTAMP, nullable=False, server_default=text('CURRENT_TIMESTAMP')) updated_at = Column(TIMESTAMP, nullable=False, server_default=text('CURRENT_TIMESTAMP'), onupdate=text('CURRENT_TIMESTAMP')) # routers/auth.py from fastapi import APIRouter, Depends, HTTPException, Form from sqlalchemy.orm import Session import os, requests from db import get_db from models.user import User from schemas.user import ( RegisterRequest, RegisterResponse, LoginRequest, LoginResponse, GoogleLoginRequest, NaverLoginRequest, KakaoLoginRequest ) from utils.password import hash_password, verify_password from utils.jwt_utils import create_access_token from google.oauth2 import id_token from google.auth.transport import requests as grequests import logging from dotenv import load_dotenv load_dotenv() KAKAO_CLIENT_ID = os.getenv("KAKAO_CLIENT_ID") KAKAO_REDIRECT_URI = os.getenv("KAKAO_REDIRECT_URI") router = APIRouter(prefix="/api/v1", tags=["Auth"]) @router.post("/register", response_model=RegisterResponse) def register(req: RegisterRequest, db: Session = Depends(get_db)): # 중복 검사 if db.query(User).filter(User.id == req.loginId).first(): raise HTTPException(status_code=400, detail="Login ID already exists") if db.query(User).filter(User.email == req.email).first(): raise HTTPException(status_code=400, detail="Email already registered") # 사용자 생성 user = User( id=req.loginId, email=req.email, password=hash_password(req.password) ) db.add(user) db.commit() db.refresh(user) return RegisterResponse( message="User registered successfully", user_id=user.u_id ) @router.post("/login", response_model=LoginResponse) def login(req: LoginRequest, db: Session = Depends(get_db)): user = db.query(User).filter(User.id == req.loginId).first() if not user: raise HTTPException(status_code=404, detail="User not found") if not verify_password(req.password, user.password): raise HTTPException(status_code=401, detail="Invalid password") token = create_access_token(user_id=user.u_id) return LoginResponse( message="Login successful", user_id=user.u_id, access_token=token ) @router.post("/login/google", response_model=LoginResponse) def login_google(req: GoogleLoginRequest, db: Session = Depends(get_db)): try: id_info = id_token.verify_oauth2_token( req.token, grequests.Request(), os.getenv("GOOGLE_CLIENT_ID") ) except Exception: raise HTTPException(status_code=401, detail="Invalid Google token") google_id = id_info.get("sub") email = id_info.get("email") user = db.query(User).filter( User.id == google_id, User.provider == 'google' ).first() if not user: user = User( id=google_id, email=email, password="google_dummy", provider="google" ) db.add(user) db.commit() db.refresh(user) token = create_access_token(user_id=user.u_id) return LoginResponse( message="Google login success", user_id=user.u_id, access_token=token ) @router.post("/login/naver", response_model=LoginResponse) def login_naver(req: NaverLoginRequest, db: Session = Depends(get_db)): # 1) 액세스 토큰 요청 token_url = ( f"https://nid.naver.com/oauth2.0/token" f"?grant_type=authorization_code" f"&client_id={os.getenv('NAVER_CLIENT_ID')}" f"&client_secret={os.getenv('NAVER_CLIENT_SECRET')}" f"&code={req.code}&state={req.state}" ) token_res = requests.get(token_url) if token_res.status_code != 200: raise HTTPException(status_code=400, detail="Naver token 요청 실패") access_token = token_res.json().get("access_token") headers = {"Authorization": f"Bearer {access_token}"} # 2) 프로필 정보 요청 profile_res = requests.get( "https://openapi.naver.com/v1/nid/me", headers=headers ) profile_data = profile_res.json() if profile_data.get("resultcode") != "00": raise HTTPException(status_code=400, detail="Naver 사용자 정보 요청 실패") naver_id = profile_data["response"]["id"] email = profile_data["response"].get("email", f"{naver_id}@naver.local") # 3) DB 조회 또는 생성 user = db.query(User).filter( User.id == naver_id, User.provider == 'naver' ).first() if not user: user = User( id=naver_id, email=email, password="naver_dummy", provider="naver" ) db.add(user) db.commit() db.refresh(user) token = create_access_token(user_id=user.u_id) return LoginResponse( message="Naver login success", user_id=user.u_id, access_token=token ) # 카카오 콜백 라우터 @router.post("/auth/kakao/callback", response_model=LoginResponse) def kakao_callback(code: str = Form(...), db: Session = Depends(get_db)): logging.warning(f"받은 code: {code}") token_url = "https://kauth.kakao.com/oauth/token" token_data = { "grant_type": "authorization_code", "client_id": KAKAO_CLIENT_ID, "redirect_uri": KAKAO_REDIRECT_URI, "code": code, } token_headers = { "Content-Type": "application/x-www-form-urlencoded" } token_res = requests.post(token_url, data=token_data, headers=token_headers) if token_res.status_code != 200: raise HTTPException(status_code=400, detail="Kakao token 요청 실패") access_token = token_res.json().get("access_token") if not access_token: raise HTTPException(status_code=400, detail="액세스 토큰 없음") profile_res = requests.get( "https://kapi.kakao.com/v2/user/me", headers={"Authorization": f"Bearer {access_token}"} ) if profile_res.status_code != 200: raise HTTPException(status_code=400, detail="Kakao 사용자 정보 요청 실패") kakao_info = profile_res.json() kakao_id = str(kakao_info.get("id")) kakao_account = kakao_info.get("kakao_account", {}) email = kakao_account.get("email", f"{kakao_id}@kakao.com") user = db.query(User).filter(User.id == kakao_id, User.provider == "kakao").first() if not user: user = User(id=kakao_id, email=email, password="kakao_dummy", provider="kakao") db.add(user) db.commit() db.refresh(user) token = create_access_token(user_id=user.u_id) return LoginResponse( message="Kakao login success", user_id=user.u_id, access_token=token ) # backend/routers/file.py import os import urllib.parse import io import numpy as np # numpy 임포트 (이미지를 배열로 변환하기 위함) from typing import List, Optional from fastapi import APIRouter, Depends, UploadFile, File, Form, HTTPException, status from fastapi.responses import FileResponse from sqlalchemy.orm import Session from db import get_db from models.file import File as FileModel from models.note import Note as NoteModel # Note 모델 임포트 from utils.jwt_utils import get_current_user from models.user import User # ------------------------------- # 1) PIL(Image) 및 OCR 라이브러리 임포트 # ------------------------------- from PIL import Image # PIL.Image 임포트 from easyocr import Reader # EasyOCR Reader 임포트 # Korean, English 지원, GPU 사용 reader = Reader(["ko", "en"], gpu=True) # EasyOCR Reader 초기화 # ------------------------------- # 2) Summarization 모델 로드 (기존 코드 유지하되 주석 처리) # ------------------------------- from transformers import pipeline summarizer = pipeline( "summarization", model="facebook/bart-large-cnn", tokenizer="facebook/bart-large-cnn", device=-1 # CPU 사용. GPU 사용 시 0 또는 적절한 번호로 변경 ) # 업로드 디렉토리 설정 BASE_UPLOAD_DIR = os.path.join( os.path.dirname(os.path.abspath(__file__)), "..", "uploads" ) os.makedirs(BASE_UPLOAD_DIR, exist_ok=True) router = APIRouter(prefix="/api/v1/files", tags=["Files"]) @router.post( "/upload", summary="폴더에 파일 업로드", status_code=status.HTTP_201_CREATED ) async def upload_file( folder_id: Optional[int] = Form(None), upload_file: UploadFile = File(...), db: Session = Depends(get_db), current_user: User = Depends(get_current_user) ): orig_filename: str = upload_file.filename or "unnamed" content_type: str = upload_file.content_type or "application/octet-stream" # 사용자별 디렉토리 생성 user_dir = os.path.join(BASE_UPLOAD_DIR, str(current_user.u_id)) os.makedirs(user_dir, exist_ok=True) # 원본 파일명 그대로 저장 (동명이인 방지) saved_filename = orig_filename saved_path = os.path.join(user_dir, saved_filename) if os.path.exists(saved_path): name, ext = os.path.splitext(orig_filename) counter = 1 while True: candidate = f"{name}_{counter}{ext}" candidate_path = os.path.join(user_dir, candidate) if not os.path.exists(candidate_path): saved_filename = candidate saved_path = candidate_path break counter += 1 # 파일 저장 try: with open(saved_path, "wb") as buffer: content = await upload_file.read() buffer.write(content) except Exception as e: raise HTTPException(status_code=500, detail=f"파일 저장 실패: {e}") # DB에 메타데이터 기록 new_file = FileModel( user_id=current_user.u_id, folder_id=folder_id, original_name=orig_filename, saved_path=saved_path, content_type=content_type ) db.add(new_file) db.commit() db.refresh(new_file) return { "file_id": new_file.id, "original_name": new_file.original_name, "folder_id": new_file.folder_id, "content_type": new_file.content_type, "created_at": new_file.created_at } @router.get( "/list/{folder_id}", response_model=List[dict], summary="특정 폴더에 속한 파일 목록 조회" ) def list_files_in_folder( folder_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user) ): files = ( db.query(FileModel) .filter( FileModel.folder_id == folder_id, FileModel.user_id == current_user.u_id ) .order_by(FileModel.created_at.desc()) .all() ) return [ { "file_id": f.id, "original_name": f.original_name, "content_type": f.content_type, "created_at": f.created_at } for f in files ] @router.get( "/download/{file_id}", summary="파일 미리보기 (인증 없이 바로 열림)" ) def download_file( file_id: int, db: Session = Depends(get_db), ): file_obj = db.query(FileModel).filter(FileModel.id == file_id).first() if not file_obj: raise HTTPException(status_code=404, detail="파일을 찾을 수 없습니다.") file_path = file_obj.saved_path if not os.path.exists(file_path): raise HTTPException(status_code=404, detail="서버에 파일이 존재하지 않습니다.") filename_star = urllib.parse.quote(file_obj.original_name, safe='') content_disposition = f"inline; filename*=UTF-8''{filename_star}" return FileResponse( path=file_path, media_type=file_obj.content_type, headers={"Content-Disposition": content_disposition} ) @router.post( "/ocr", summary="이미지 OCR → 텍스트 변환 후 노트 생성", response_model=dict ) async def ocr_and_create_note( ocr_file: UploadFile = File(...), folder_id: Optional[int] = Form(None), # 노트를 저장할 폴더 ID (선택) db: Session = Depends(get_db), current_user: User = Depends(get_current_user) ): """ • ocr_file: 이미지 파일(UploadFile) • 1) EasyOCR 모델로 텍스트 인식 (한글·영어 지원, GPU 사용) • 2) 인식된 텍스트를 새로운 Note 모델로 저장 • 결과: {"note_id": 새로 생성된 노트 ID, "text": "인식된 텍스트"} 반환 """ # ---------- # 1) 이미지 처리 → OCR 텍스트 추출 # ---------- contents = await ocr_file.read() try: image = Image.open(io.BytesIO(contents)).convert("RGB") except Exception as e: raise HTTPException(status_code=400, detail=f"이미지 처리 실패: {e}") try: # PIL 이미지를 numpy 배열로 변환 image_np = np.array(image) # EasyOCR로 텍스트 추출 results = reader.readtext(image_np) if not results: raise ValueError("텍스트를 인식할 수 없습니다.") # 인식된 텍스트들 결합 ocr_text = " ".join([res[1] for res in results]) except Exception as e: raise HTTPException(status_code=500, detail=f"OCR 수행 실패: {e}") # ---------- # 2) Summarization 부분 주석 처리 # ---------- # try: # summary_list = summarizer( # ocr_text, # max_length=120, # min_length=30, # do_sample=False # ) # summarized_text = summary_list[0]["summary_text"] # except Exception as e: # summarized_text = "" # print(f"[OCR & Summarization] 요약 중 오류 발생: {e}") # ---------- # 3) 새 노트 생성 및 DB에 저장 (이미지 텍스트 결과 저장) # ---------- try: new_note = NoteModel( user_id=current_user.u_id, folder_id=folder_id, title="OCR 결과", # 고정 제목. 필요 시 변경 가능 content=ocr_text ) db.add(new_note) db.commit() db.refresh(new_note) except Exception as e: raise HTTPException(status_code=500, detail=f"노트 저장 실패: {e}") return { "note_id": new_note.id, "text": ocr_text } # Backend/routers/folder.py from fastapi import APIRouter, Depends, HTTPException, status from sqlalchemy.orm import Session from typing import List, Optional from db import get_db from models.folder import Folder from models.note import Note from schemas.folder import FolderCreate, FolderResponse, FolderUpdate from schemas.note import NoteResponse from utils.jwt_utils import get_current_user router = APIRouter(prefix="/api/v1", tags=["Folders"]) def get_all_descendant_folder_ids(db: Session, parent_id: int, user_id: int) -> List[int]: """ ● 폴더를 삭제할 때, 하위 폴더(자손)들까지 전부 삭제하기 위해 재귀적으로 descendant ID를 수집합니다. """ result: List[int] = [] stack = [parent_id] while stack: current = stack.pop() result.append(current) children = ( db .query(Folder.id) .filter(Folder.parent_id == current, Folder.user_id == user_id) .all() ) stack.extend([child.id for child in children]) return result @router.get( "/folders", response_model=List[FolderResponse], summary="유저의 모든 폴더(트리 구조) 및 폴더별 노트 리스트 반환" ) def list_folders( db: Session = Depends(get_db), user = Depends(get_current_user) ): """ 1) 해당 유저의 모든 폴더와 노트를 가져옵니다. 2) 노트들은 folder_id 기준으로 그룹핑합니다. 3) 각 폴더 객체에 children(하위폴더)와 notes(폴더 내 노트) 속성을 동적으로 붙입니다. 4) 부모가 없는(root) 폴더만 뽑아서 트리 형태(List[Folder])로 반환합니다. """ all_folders = db.query(Folder).filter(Folder.user_id == user.u_id).all() all_notes = db.query(Note).filter(Note.user_id == user.u_id).all() # (2) 노트들을 folder_id 기준으로 그룹핑 folder_note_map: dict[int, List[Note]] = {} for n in all_notes: folder_note_map.setdefault(n.folder_id, []).append(n) # (3) Folder 객체에 children, notes 속성 추가 id_map = {f.id: f for f in all_folders} for f in all_folders: setattr(f, 'children', []) # children: List[Folder] setattr(f, 'notes', folder_note_map.get(f.id, [])) # notes: List[Note] # (4) 트리 형태 구성 roots: List[Folder] = [] for f in all_folders: if f.parent_id is not None and f.parent_id in id_map: id_map[f.parent_id].children.append(f) else: roots.append(f) return roots @router.post( "/folders", response_model=FolderResponse, status_code=status.HTTP_201_CREATED, summary="새 폴더 생성" ) def create_folder( req: FolderCreate, db: Session = Depends(get_db), user = Depends(get_current_user) ): """ • req.name (문자열, 필수) • req.parent_id (정수 or null) - 최상위 폴더면 None """ new_folder = Folder( user_id = user.u_id, name = req.name, parent_id = req.parent_id ) db.add(new_folder) db.commit() db.refresh(new_folder) # children, notes 속성 초기화 setattr(new_folder, 'children', []) setattr(new_folder, 'notes', []) return new_folder @router.patch( "/folders/{folder_id}", response_model=FolderResponse, summary="폴더 이름 변경 및/또는 부모 폴더 이동" ) def update_folder( folder_id: int, req: FolderUpdate, db: Session = Depends(get_db), user = Depends(get_current_user) ): """ ● 이름(name) 변경이 있으면 바꿔주고, ● 부모폴더(parent_id) 변경이 있으면 바꿔줍니다. (자신을 자신의 하위로 지정하는 경우를 방지하려면 프론트에서 부모ID 검증 혹은 백엔드에서 추가 검증 필요) """ folder = ( db .query(Folder) .filter(Folder.id == folder_id, Folder.user_id == user.u_id) .first() ) if not folder: raise HTTPException(status_code=404, detail="Folder not found") if req.name is not None: folder.name = req.name if req.parent_id is not None: folder.parent_id = req.parent_id db.commit() db.refresh(folder) # 응답 시 children, notes는 빈 배열로 초기화 setattr(folder, 'children', []) setattr(folder, 'notes', []) return folder @router.delete( "/folders/{folder_id}", summary="폴더 및 모든 하위 폴더·노트 일괄 삭제" ) def delete_folder( folder_id: int, db: Session = Depends(get_db), user = Depends(get_current_user) ): """ 1) 해당 폴더(및 하위폴더)의 ID 목록을 재귀적으로 수집 2) 그 ID들에 속한 노트들을 모두 삭제 3) 그 ID들에 속한 폴더들을 모두 삭제 """ folder = ( db .query(Folder) .filter(Folder.id == folder_id, Folder.user_id == user.u_id) .first() ) if not folder: raise HTTPException(status_code=404, detail="Folder not found") all_folder_ids = get_all_descendant_folder_ids(db, folder_id, user.u_id) # (2) 해당 폴더들 안의 모든 노트 삭제 db.query(Note).filter(Note.folder_id.in_(all_folder_ids)).delete(synchronize_session=False) # (3) 해당 폴더들 삭제 db.query(Folder).filter(Folder.id.in_(all_folder_ids)).delete(synchronize_session=False) db.commit() return {"message": f"Deleted folder and its {len(all_folder_ids)-1} subfolders."} # src/routers/note.py import os import requests from dotenv import load_dotenv from fastapi import APIRouter, Depends, HTTPException, status from sqlalchemy.orm import Session from typing import List from datetime import datetime from db import get_db from models.note import Note from schemas.note import NoteCreate, NoteUpdate, NoteResponse, FavoriteUpdate from utils.jwt_utils import get_current_user load_dotenv() HF_TOKEN = os.getenv("HF_API_TOKEN") router = APIRouter(prefix="/api/v1", tags=["Notes"]) # 모든 노트 조회 @router.get("/notes", response_model=List[NoteResponse]) def list_notes( db: Session = Depends(get_db), user = Depends(get_current_user) ): return ( db.query(Note) .filter(Note.user_id == user.u_id) .order_by(Note.created_at.desc()) .all() ) # 최근 접근한 노트 조회 (상위 10개로 변경) @router.get("/notes/recent", response_model=List[NoteResponse]) def recent_notes( db: Session = Depends(get_db), user = Depends(get_current_user) ): return ( db.query(Note) .filter(Note.user_id == user.u_id, Note.last_accessed.isnot(None)) .order_by(Note.last_accessed.desc()) .limit(10) # ← 기존 5 → 10 .all() ) # 노트 생성 @router.post("/notes", response_model=NoteResponse) def create_note( req: NoteCreate, db: Session = Depends(get_db), user = Depends(get_current_user) ): note = Note( user_id=user.u_id, folder_id=req.folder_id, title=req.title, content=req.content ) db.add(note) db.commit() db.refresh(note) return note # 노트 수정 (제목/내용/폴더) – NoteUpdate 사용 @router.patch("/notes/{note_id}", response_model=NoteResponse) def update_note( note_id: int, req: NoteUpdate, # NoteUpdate 로 변경 db: Session = Depends(get_db), user = Depends(get_current_user) ): note = db.query(Note).filter(Note.id == note_id, Note.user_id == user.u_id).first() if not note: raise HTTPException(status_code=404, detail="Note not found") # Optional 필드만 업데이트 if req.title is not None: note.title = req.title if req.content is not None: note.content = req.content if req.folder_id is not None: note.folder_id = req.folder_id note.updated_at = datetime.utcnow() db.commit() db.refresh(note) return note # 노트 단일 조회 @router.get("/notes/{note_id}", response_model=NoteResponse) def get_note( note_id: int, db: Session = Depends(get_db), user = Depends(get_current_user) ): note = db.query(Note).filter(Note.id == note_id, Note.user_id == user.u_id).first() if not note: raise HTTPException(404, "Note not found") # 조회 시 마지막 접근 시간 갱신 note.last_accessed = datetime.utcnow() db.commit() db.refresh(note) return note # 노트 삭제 @router.delete("/notes/{note_id}") def delete_note( note_id: int, db: Session = Depends(get_db), user = Depends(get_current_user) ): note = db.query(Note).filter(Note.id == note_id, Note.user_id == user.u_id).first() if not note: raise HTTPException(status_code=404, detail="Note not found") db.delete(note) db.commit() return {"message": "Note deleted successfully"} # 즐겨찾기 토글 @router.patch("/notes/{note_id}/favorite", response_model=NoteResponse) def toggle_favorite( note_id: int, req: FavoriteUpdate, db: Session = Depends(get_db), user = Depends(get_current_user) ): note = db.query(Note).filter(Note.id == note_id, Note.user_id == user.u_id).first() if not note: raise HTTPException(status_code=404, detail="Note not found") note.is_favorite = req.is_favorite note.updated_at = datetime.utcnow() db.commit() db.refresh(note) return note # 노트 요약 (LLM 호출) @router.post("/notes/{note_id}/summarize", response_model=NoteResponse) def summarize_note( note_id: int, db: Session = Depends(get_db), user = Depends(get_current_user) ): note = db.query(Note).filter( Note.id == note_id, Note.user_id == user.u_id ).first() if not note: raise HTTPException(404, "Note not found") original = note.content or "" if not original.strip(): raise HTTPException(400, "내용이 비어 있어 요약할 수 없습니다.") # 실제 요약 함수 호출 from utils.llm import summarize_with_qwen3 # ← 이 시점에 utils/llm.py가 로드되며 오류 발생 load_dotenv() HF_TOKEN = os.getenv("HF_API_TOKEN") note.updated_at = datetime.utcnow() db.commit() db.refresh(note) return note # Backend/schemas/folder.py from pydantic import BaseModel from typing import Optional, List from schemas.note import NoteResponse class FolderCreate(BaseModel): name: str parent_id: Optional[int] = None class FolderUpdate(BaseModel): name: Optional[str] = None parent_id: Optional[int] = None class FolderResponse(BaseModel): id: int user_id: int name: str parent_id: Optional[int] children: List['FolderResponse'] = [] notes: List[NoteResponse] = [] class Config: from_attributes = True FolderResponse.update_forward_refs() # src/schemas/note.py from pydantic import BaseModel from typing import Optional from datetime import datetime class NoteCreate(BaseModel): title: str content: Optional[str] = None folder_id: Optional[int] = None class NoteUpdate(BaseModel): title: Optional[str] = None content: Optional[str] = None folder_id: Optional[int] = None # 필요에 따라 is_favorite 같은 필드도 추가 가능 is_favorite: Optional[bool] = None class FavoriteUpdate(BaseModel): is_favorite: bool class NoteResponse(BaseModel): id: int user_id: int folder_id: Optional[int] title: str content: Optional[str] is_favorite: bool last_accessed: Optional[datetime] created_at: datetime updated_at: datetime class Config: from_attributes = True # schemas/user.py from pydantic import BaseModel class RegisterRequest(BaseModel): loginId: str email: str password: str class RegisterResponse(BaseModel): message: str user_id: int # int 타입으로 변경 class LoginRequest(BaseModel): loginId: str password: str class LoginResponse(BaseModel): message: str user_id: int # int 타입으로 변경 access_token: str class KakaoLoginRequest(BaseModel): code: str class GoogleLoginRequest(BaseModel): token: str class NaverLoginRequest(BaseModel): code: str state: str import smtplib from email.mime.text import MIMEText from email_validator import validate_email, EmailNotValidError from fastapi import HTTPException # 인증 코드 생성 함수 def generate_verification_code(): import random return str(random.randint(100000, 999999)) # 이메일 전송 함수 def send_email(smtp_user: str, smtp_password: str, email: str, code: str): smtp_server = "smtp.gmail.com" smtp_port = 587 subject = "AI Keeper 인증 메일입니다." body = f"인증코드: {code}" msg = MIMEText(body) msg["Subject"] = subject msg["From"] = smtp_user msg["To"] = email # 이메일 유효성 검사 try: valid = validate_email(email) email = valid.email # 정제된 이메일 주소 반환 except EmailNotValidError as e: raise HTTPException(status_code=400, detail="Invalid email address.") try: # SMTP 서버 설정 및 이메일 전송 with smtplib.SMTP(smtp_server, smtp_port) as server: server.starttls() server.login(smtp_user, smtp_password) server.sendmail(smtp_user, email, msg.as_string()) except Exception as e: raise HTTPException(status_code=500, detail="Failed to send email.") # utils/jwt_utils.py import os from datetime import datetime, timedelta, timezone from jose import JWTError, jwt import bcrypt from fastapi import HTTPException, Depends from fastapi.security import OAuth2PasswordBearer from sqlalchemy.orm import Session from models.user import User from db import get_db SECRET_KEY = os.getenv("SECRET_KEY", "your_secret_key") ALGORITHM = "HS256" oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/login") def verify_password(plain_password: str, hashed_password: str) -> bool: return bcrypt.checkpw(plain_password.encode(), hashed_password.encode()) def hash_password(password: str) -> str: return bcrypt.hashpw(password.encode(), bcrypt.gensalt(rounds=12)).decode() def create_access_token(user_id: int, expires_delta: timedelta | None = None) -> str: expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes=15)) payload = {"sub": str(user_id), "exp": expire} return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM) async def get_current_user( token: str = Depends(oauth2_scheme), db: Session = Depends(get_db) ): credentials_exception = HTTPException( status_code=401, detail="Could not validate credentials", headers={"WWW-Authenticate": "Bearer"}, ) try: payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) user_id: str = payload.get("sub") if not user_id: raise credentials_exception except JWTError: raise credentials_exception user = db.query(User).filter(User.u_id == int(user_id)).first() if not user: raise credentials_exception return user # ~/noteflow/Backend/utils/llm.py import torch from transformers import AutoConfig, AutoTokenizer, AutoModelForCausalLM _MODEL_NAME = "Qwen/Qwen3-8B" # 1) Config 불러와서 parallel_style 지정 config = AutoConfig.from_pretrained( _MODEL_NAME, trust_remote_code=True ) # 변경: 반드시 "auto"로 지정. NoneType 오류 방지 config.parallel_style = "auto" # 2) 토크나이저 로드 _tokenizer = AutoTokenizer.from_pretrained( _MODEL_NAME, trust_remote_code=True ) # 3) 모델 로드 시 config 인자 추가 _model = AutoModelForCausalLM.from_pretrained( _MODEL_NAME, config=config, # custom config 전달 torch_dtype="auto", device_map="auto", trust_remote_code=True ) _model.eval() def summarize_with_qwen3( text: str, max_new_tokens: int = 256, temperature: float = 0.6 ) -> str: """ - 한국어 문서를 간결하고 핵심적으로 요약 - 반환값: 요약된 한국어 문자열 """ messages = [ { "role": "system", "content": ( "당신은 한국어 문서를 간결하고 핵심적으로 요약하는 전문가입니다. " "요약 외에는 절대 다른 말을 하지 마세요." ) }, { "role": "user", "content": text } ] # apply_chat_template: enable_thinking=False 전달 prompt = _tokenizer.apply_chat_template( messages, tokenize=False, add_generation_prompt=True, enable_thinking=False ) inputs = _tokenizer(prompt, return_tensors="pt").to(_model.device) outputs = _model.generate( **inputs, max_new_tokens=max_new_tokens, temperature=temperature, top_p=0.95, top_k=20, do_sample=False, # 안정적인 요약을 위해 샘플링 끄기 eos_token_id=_tokenizer.eos_token_id ) # 생성된 토큰 중 입력 이후 부분만 디코딩 gen_tokens = outputs[0].tolist()[len(inputs.input_ids[0]):] decoded = _tokenizer.decode(gen_tokens, skip_special_tokens=True) return decoded.strip() import random import string import bcrypt def generate_temp_password(length=10): """ 랜덤한 임시 비밀번호 생성 (영문 + 숫자 조합) """ characters = string.ascii_letters + string.digits return ''.join(random.choice(characters) for _ in range(length)) def hash_password(password: str) -> str: """ 주어진 비밀번호를 bcrypt 해시로 변환 """ return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(rounds=12)).decode('utf-8') def verify_password(input_password: str, hashed_password: str) -> bool: """ 입력된 비밀번호가 해시된 비밀번호와 일치하는지 확인 """ return bcrypt.checkpw(input_password.encode('utf-8'), hashed_password.encode('utf-8')) from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker DATABASE_URL = "mysql+mysqlconnector://noteflow:NoteFlow123!@localhost/noteflow" engine = create_engine(DATABASE_URL) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) # 데이터베이스 의존성 def get_db(): db = SessionLocal() try: yield db finally: db.close() # src/main.py import os from dotenv import load_dotenv from fastapi import FastAPI from fastapi.middleware.cors import CORSMiddleware from routers.auth import router as auth_router from routers.note import router as note_router from routers.folder import router as folder_router from fastapi.staticfiles import StaticFiles from routers.file import router as file_router import logging import uvicorn # 1) 환경변수 로드 load_dotenv() # 2) 로깅 설정 logging.basicConfig(level=logging.INFO) logger = logging.getLogger(__name__) # 3) FastAPI 앱 생성 app = FastAPI() # 4) CORS 설정 origins = [ "http://localhost:5174", ] app.add_middleware( CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"], ) # 5) 라우터 등록 app.include_router(auth_router) app.include_router(note_router) app.include_router(folder_router) app.include_router(file_router) # 6) 루트 엔드포인트 @app.get("/") def read_root(): return {"message": "mini"} # 7) 실행 설정 if __name__ == "__main__": uvicorn.run( "main:app", host="0.0.0.0", port=8080, reload=True, env_file=".env" )

###### ChatGPT의 말:

백엔드 코드와 디렉터리 구조 확인했습니다.  
다음으로 프론트엔드 쪽 코드와 파일 구조를 공유해 주시면, 이어서 살펴보겠습니다.

##### 나의 말:

// src/components/BottomBar.jsx import React from 'react' import '../css/Bottombar.css' export default function BottomBar({ statusText, onRecordClick, onSummarizeClick, onUploadClick, onOcrClick // 추가된 prop }) { return ( <footer className="bottom-bar"> <div className="bottom-status"> {statusText && <span>🔵 {statusText}</span>} </div> <div className="bottom-actions"> <button onClick={onRecordClick}>녹음</button> <button onClick={onSummarizeClick}>요약</button> <button onClick={onUploadClick}>업로드</button> <button onClick={onOcrClick}>텍스트 변환</button> {/* 새 버튼 */} </div> </footer> ) } // src/components/Layout.jsx import React, { useState, useRef, useEffect } from 'react' import { Outlet, useNavigate, useParams } from 'react-router-dom' import Sidebar from './Sidebar' import TopBar from './Topbar' import BottomBar from './Bottombar' import '../css/Layout.css' import '../css/Modal.css' // 모달 전용 스타일 (아래에 설명) export default function Layout() { const navigate = useNavigate() const { folderId: folderIdParam } = useParams() const parsedFolderId = folderIdParam ? parseInt(folderIdParam, 10) : null // ──────────────────────────────────────────────────────────────── // 1) 검색, 필터, 현재 노트, 현재 폴더 상태 // ──────────────────────────────────────────────────────────────── const [search, setSearch] = useState('') const [filter, setFilter] = useState('all') const [currentNote, setCurrentNote] = useState(null) const [selectedFolderId, setSelectedFolderId] = useState(parsedFolderId) useEffect(() => { setSelectedFolderId(parsedFolderId) }, [parsedFolderId]) // ──────────────────────────────────────────────────────────────── // 2) 녹음 / 요약 / OCR 상태 텍스트 // ──────────────────────────────────────────────────────────────── const [statusText, setStatusText] = useState('') const handleRecord = () => setStatusText('🔴 녹음이 진행중입니다...') const handleSummarize = async () => { if (!currentNote) return setStatusText('⏳ 요약을 수행 중입니다...') const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') try { const res = await fetch( `${API}/api/v1/notes/${currentNote.id}/summarize`, { method: 'POST', headers: { Authorization: `Bearer ${token}` } } ) if (!res.ok) { alert('요약에 실패했습니다') setStatusText('') return } const updated = await res.json() setCurrentNote(updated) setStatusText('✅ 요약 완료') } catch (err) { console.error('[Layout] 요약 중 예외:', err) alert('요약 처리 중 오류가 발생했습니다.') setStatusText('') } } const toggleFavorite = async () => { if (!currentNote) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') try { const res = await fetch( `${API}/api/v1/notes/${currentNote.id}/favorite`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ is_favorite: !currentNote.is_favorite }) } ) if (res.ok) { const updated = await res.json() setCurrentNote(updated) } else { alert('즐겨찾기 변경 실패') } } catch (err) { console.error('[Layout] 즐겨찾기 처리 중 예외:', err) alert('즐겨찾기 처리 중 오류가 발생했습니다.') } } const handleNewNote = () => navigate('/notes/new') // ──────────────────────────────────────────────────────────────── // 3) 파일 업로드 처리 // ──────────────────────────────────────────────────────────────── const fileInputRef = useRef() const ocrInputRef = useRef() // OCR 전용 파일 input ref const [uploadTargetFolderId, setUploadTargetFolderId] = useState(null) const handleUploadClick = () => { if (selectedFolderId == null) { alert('먼저 사이드바에서 업로드할 폴더를 선택하세요.') return } setUploadTargetFolderId(selectedFolderId) if (fileInputRef.current) fileInputRef.current.click() } const [fileUploadTimestamp, setFileUploadTimestamp] = useState(0) const handleFilesSelected = async (e) => { const files = e.target.files if (!files || files.length === 0) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') const folderIdToUpload = uploadTargetFolderId if (!folderIdToUpload) { alert('유효한 폴더 ID가 없습니다. 업로드를 취소합니다.') e.target.value = null return } for (let i = 0; i < files.length; i++) { const file = files[i] const formData = new FormData() formData.append('upload_file', file) formData.append('folder_id', String(folderIdToUpload)) console.log(`[Layout] 파일 업로드 요청 → "${file.name}" → 폴더 ${folderIdToUpload}`) try { const res = await fetch(`${API}/api/v1/files/upload`, { method: 'POST', headers: { Authorization: `Bearer ${token}` }, body: formData }) if (!res.ok) { console.error( `[Layout] 파일 업로드 실패: "${file.name}"`, res.status, await res.text() ) } else { console.log(`[Layout] 파일 업로드 성공: "${file.name}"`) } } catch (err) { console.error(`[Layout] 파일 업로드 중 예외: "${file.name}"`, err) } } setFileUploadTimestamp(Date.now()) setUploadTargetFolderId(null) e.target.value = null } // ──────────────────────────────────────────────────────────────── // 4) OCR 전용 파일 선택 처리 (OCR → 요약 → 노트 저장 → 모달 띄우기) // ──────────────────────────────────────────────────────────────── // (1) 모달 표시를 위한 상태 const [showModal, setShowModal] = useState(false) const [modalTitle, setModalTitle] = useState('') const [modalBody, setModalBody] = useState('') const handleOcrClick = () => { if (selectedFolderId == null) { alert('먼저 사이드바에서 OCR을 수행할 폴더를 선택하세요.') return } if (ocrInputRef.current) ocrInputRef.current.click() } const handleOcrSelected = async (e) => { const files = e.target.files if (!files || files.length === 0) return const file = files[0] // 첫 번째 파일만 처리 const formData = new FormData() formData.append('ocr_file', file) const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') // OCR → 요약 진행 상태 표시 setStatusText('⏳ OCR 및 요약을 수행 중입니다...') try { const res = await fetch(`${API}/api/v1/files/ocr`, { method: 'POST', headers: { Authorization: `Bearer ${token}` }, body: formData }) if (!res.ok) { alert('이미지 텍스트 변환에 실패했습니다.') setStatusText('') return } // 서버로부터 { text, summary } 형태의 JSON 응답을 받음 const { text, summary } = await res.json() // (2) 요약 결과를 새로운 노트로 저장 let newNoteData = null if (summary && summary.trim().length > 0) { const notePayload = { title: `[OCR 요약] ${file.name}`, content: summary, folder_id: selectedFolderId } const noteRes = await fetch(`${API}/api/v1/notes`, { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify(notePayload) }) if (noteRes.ok) { newNoteData = await noteRes.json() } else { console.error( '[Layout] 요약 노트 생성 실패:', noteRes.status, await noteRes.text() ) } } // (3) 모달에 렌더링할 내용 구성 let bodyHtml = `<h3>OCR 결과</h3><pre class="modal-pre">${text}</pre>` if (summary && summary.trim().length > 0) { bodyHtml += `<h3>요약 결과</h3><pre class="modal-pre">${summary}</pre>` if (newNoteData) { bodyHtml += `<p>✅ 요약을 새 노트로 저장했습니다: “${newNoteData.title}”</p>` } else { bodyHtml += `<p style="color: #d00;">⚠️ 요약 노트 저장에 실패했습니다.</p>` } } else { bodyHtml += `<p>⚠️ 요약된 내용이 없습니다.</p>` } // (4) 모달 표시 setModalTitle('OCR & 요약 결과') setModalBody(bodyHtml) setShowModal(true) setStatusText('✅ OCR 및 요약 완료') } catch (err) { console.error('[Layout] OCR 중 예외:', err) alert('OCR 처리 중 오류가 발생했습니다.') setStatusText('') } finally { e.target.value = null } } // 모달 닫기 함수 const closeModal = () => { setShowModal(false) setModalTitle('') setModalBody('') } return ( <div className="layout-container"> <Sidebar onFilterChange={setFilter} onSelectFolder={setSelectedFolderId} onNoteSelect={setCurrentNote} /> <div className="layout-body"> <TopBar onNewNote={handleNewNote} searchValue={search} onSearchChange={setSearch} onFavoritesClick={() => setFilter('favorites')} onSettingsClick={() => navigate('/settings')} currentNote={currentNote} onToggleFavorite={toggleFavorite} /> <div className="layout-main"> <Outlet context={{ setCurrentNote, toggleFavorite, filter, selectedFolderId, fileUploadTimestamp, }} /> </div> <BottomBar statusText={statusText} onRecordClick={handleRecord} onSummarizeClick={handleSummarize} onUploadClick={handleUploadClick} onOcrClick={handleOcrClick} // BottomBar에 OCR 클릭 핸들러 전달 /> </div> {/* 숨겨진 파일 input (폴더 업로드용) */} <input type="file" ref={fileInputRef} style={{ display: 'none' }} multiple onChange={handleFilesSelected} /> {/* 숨겨진 파일 input (OCR용, single 파일 처리) */} <input type="file" ref={ocrInputRef} style={{ display: 'none' }} accept="image/*" onChange={handleOcrSelected} /> {/* ─────────────────────────────────────────────────────────────────── 모달 컴포넌트 (showModal=true일 때 화면 중앙에 오버레이) ─────────────────────────────────────────────────────────────────── */} {showModal && ( <div className="modal-overlay" onClick={closeModal}> <div className="modal-dialog" onClick={(e) => e.stopPropagation()}> <div className="modal-header"> <h2>{modalTitle}</h2> <button className="modal-close-btn" onClick={closeModal}>×</button> </div> <div className="modal-content" dangerouslySetInnerHTML={{ __html: modalBody }} /> <div className="modal-footer"> <button className="modal-ok-btn" onClick={closeModal}> 확인 </button> </div> </div> </div> )} </div> ) } // src/components/Sidebar.jsx import React, { useState, useEffect, useCallback, useRef } from 'react' import { useNavigate } from 'react-router-dom' import '../css/Sidebar.css' export default function Sidebar({ onFilterChange, onSelectFolder, onNoteSelect }) { // 1) 로컬 상태 const [flatFolders, setFlatFolders] = useState([]) // 서버에서 받아온 폴더 리스트 (평탄화된 배열) const [treeFolders, setTreeFolders] = useState([]) // 트리 구조로 변환된 폴더들 const [openMap, setOpenMap] = useState({}) // 폴더 열림/닫힘 상태 const [folderNoteMap, setFolderNoteMap] = useState({}) // 폴더별 노트 매핑 const [folderContextMenu, setFolderContextMenu] = useState({ visible: false, x: 0, y: 0, folderId: null }) const [noteContextMenu, setNoteContextMenu] = useState({ visible: false, x: 0, y: 0, noteId: null, folderId: null }) const [activeFilter, setActiveFilter] = useState('all') // 'all' | 'recent' | 'favorites' const navigate = useNavigate() const contextMenuRef = useRef(null) // ──────────────────────────────────────────────────────────────── // 1) 폴더 목록 불러오기 (GET /api/v1/folders) // - 백엔드가 트리 형태로 리턴하므로, 이를 평탄화한 뒤 flatFolders에 저장 // ──────────────────────────────────────────────────────────────── const loadFolders = useCallback(async () => { try { const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') const res = await fetch(`${API}/api/v1/folders`, { headers: { Authorization: `Bearer ${token}` } }) if (!res.ok) { console.error('[loadFolders] 실패 →', res.status, await res.text()) return } const data = await res.json() // 트리 형태의 JSON을 재귀 탐색하여 평탄화 const flattenList = [] const traverse = (node) => { // node에는 id, user_id, name, parent_id, children, notes 속성이 존재함 flattenList.push({ id: node.id, user_id: node.user_id, name: node.name, parent_id: node.parent_id }) if (node.children && node.children.length > 0) { node.children.forEach((child) => traverse(child)) } } data.forEach((root) => traverse(root)) setFlatFolders(flattenList) } catch (err) { console.error('[loadFolders] 예외 →', err) } }, []) // ──────────────────────────────────────────────────────────────── // 2) 노트 목록 불러오기 (GET /api/v1/notes) → 폴더별 매핑 // ──────────────────────────────────────────────────────────────── const loadNotes = useCallback(async () => { try { const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') const res = await fetch(`${API}/api/v1/notes`, { headers: { Authorization: `Bearer ${token}` } }) if (!res.ok) { console.error('[loadNotes] 실패 →', res.status, await res.text()) return } const notes = await res.json() const map = {} notes.forEach((n) => { const key = n.folder_id ?? null if (!map[key]) map[key] = [] map[key].push(n) }) setFolderNoteMap(map) } catch (err) { console.error('[loadNotes] 예외 →', err) } }, []) // ──────────────────────────────────────────────────────────────── // 3) 마운트 시 폴더 & 노트 동시에 로드 // ──────────────────────────────────────────────────────────────── useEffect(() => { loadFolders() loadNotes() }, [loadFolders, loadNotes]) // ──────────────────────────────────────────────────────────────── // 4) flatFolders + folderNoteMap → 트리 구조(treeFolders)로 변환 // ──────────────────────────────────────────────────────────────── useEffect(() => { // flatFolders를 키(id) 기준으로 임시 맵핑 const tempMap = {} flatFolders.forEach((f) => { tempMap[f.id] = { ...f, children: [], notes: folderNoteMap[f.id] || [] } }) // 루트 노드 배열 생성 const roots = [] flatFolders.forEach((f) => { if (f.parent_id == null) { roots.push(tempMap[f.id]) } else if (tempMap[f.parent_id]) { tempMap[f.parent_id].children.push(tempMap[f.id]) } }) setTreeFolders(roots) }, [flatFolders, folderNoteMap]) // ──────────────────────────────────────────────────────────────── // 5) 드래그 앤 드롭: 파일 / 노트 / 폴더 드롭 이벤트 처리 // ──────────────────────────────────────────────────────────────── const handleDrop = async (e, targetFolderId) => { e.preventDefault() const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') const dataType = e.dataTransfer.getData('type') const droppedNoteId = e.dataTransfer.getData('noteId') const droppedFolderId = e.dataTransfer.getData('folderId') // 5-1) 파일 드롭 → POST /api/v1/files/upload const droppedFiles = e.dataTransfer.files if (droppedFiles && droppedFiles.length > 0) { for (let i = 0; i < droppedFiles.length; i++) { const file = droppedFiles[i] const formData = new FormData() formData.append('upload_file', file) formData.append('folder_id', targetFolderId) console.log(`[handleDrop] 파일 업로드 요청 → "${file.name}" → 폴더 ${targetFolderId}`) try { const res = await fetch(`${API}/api/v1/files/upload`, { method: 'POST', headers: { Authorization: `Bearer ${token}` }, body: formData }) if (!res.ok) { console.error(`[handleDrop] 파일 업로드 실패: "${file.name}"`, res.status, await res.text()) } else { console.log(`[handleDrop] 파일 업로드 성공: "${file.name}"`) } } catch (err) { console.error(`[handleDrop] 파일 업로드 중 예외: "${file.name}"`, err) } } await loadNotes() onFilterChange('all') return } // 5-2) 노트 드롭 → PATCH /api/v1/notes/{noteId} if (dataType === 'note' && droppedNoteId) { console.log(`[handleDrop] 노트 이동 요청 → noteId=${droppedNoteId}, targetFolderId=${targetFolderId}`) try { const res = await fetch(`${API}/api/v1/notes/${droppedNoteId}`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ folder_id: targetFolderId }) }) if (!res.ok) { console.error('[handleDrop] 노트 이동 실패:', res.status, await res.text()) } else { console.log('[handleDrop] 노트 이동 성공:', droppedNoteId, '→', targetFolderId) } await loadNotes() onFilterChange('all') } catch (err) { console.error('[handleDrop] 노트 이동 중 예외:', err) } return } // 5-3) 폴더 드롭 → PATCH /api/v1/folders/{folderId} if (dataType === 'folder' && droppedFolderId) { const dfId = parseInt(droppedFolderId, 10) const tfId = parseInt(targetFolderId, 10) console.log(`[handleDrop] 폴더 이동 요청 → folderId=${dfId}, targetFolderId=${tfId}`) if (dfId === tfId) { console.warn('[handleDrop] 자기 자신 위로 드롭 시도 → 무시') return } if (isDescendant(dfId, tfId)) { console.warn('[handleDrop] 자식 위로 드롭 시도 → 무시') return } try { const res = await fetch(`${API}/api/v1/folders/${dfId}`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ parent_id: tfId }) }) if (!res.ok) { console.error('[handleDrop] 폴더 이동 실패:', res.status, await res.text()) } else { console.log('[handleDrop] 폴더 이동 성공:', dfId, '→', tfId) } // 폴더 트리 다시 로드 await loadFolders() } catch (err) { console.error('[handleDrop] 폴더 이동 중 예외:', err) } return } } const isDescendant = (droppedId, targetId) => { const stack = [droppedId] const visited = new Set() const childMap = {} flatFolders.forEach((f) => { if (!childMap[f.parent_id]) childMap[f.parent_id] = [] childMap[f.parent_id].push(f.id) }) while (stack.length > 0) { const curr = stack.pop() if (visited.has(curr)) continue visited.add(curr) const children = childMap[curr] || [] if (children.includes(targetId)) return true stack.push(...children) } return false } // ──────────────────────────────────────────────────────────────── // 6) 폴더 / 노트 CRUD 핸들러 // ──────────────────────────────────────────────────────────────── // 6-1) 새 폴더 생성 const handleNewFolder = async (parentId) => { const name = prompt('새 폴더 이름을 입력하세요') if (!name) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') console.log('[handleNewFolder] 호출됨 → parentId=', parentId, ', name=', name) try { const res = await fetch(`${API}/api/v1/folders`, { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ name: name, parent_id: parentId }) }) console.log('[handleNewFolder] 요청 바디 →', JSON.stringify({ name, parent_id: parentId })) if (!res.ok) { console.error('[handleNewFolder] 폴더 생성 실패:', res.status, await res.text()) alert('폴더 생성 실패. 콘솔을 확인하세요.') return } const created = await res.json() console.log('[handleNewFolder] 폴더 생성 성공:', created) // ① 서버에서 최신 폴더 목록을 다시 가져옴 await loadFolders() // ② 필터 초기화(‘내 폴더’ 탭) setActiveFilter('all') onFilterChange('all') // ③ 폴더 생성 위치(부모 폴더)를 자동 확장 if (parentId !== null) { setOpenMap((prev) => ({ ...prev, [parentId]: true })) } } catch (err) { console.error('[handleNewFolder] 예외 발생:', err) alert('폴더 생성 중 예외 발생. 콘솔을 확인하세요.') } } // 6-2) 새 노트 생성 const handleNewNote = async (folderId) => { const title = prompt('노트 제목을 입력하세요') if (!title) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') console.log('[handleNewNote] 호출됨 → folderId=', folderId, ', title=', title) try { const res = await fetch(`${API}/api/v1/notes`, { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ title: title, content: '', folder_id: folderId }) }) console.log('[handleNewNote] 요청 바디 →', JSON.stringify({ title, content: '', folder_id: folderId })) if (!res.ok) { console.error('[handleNewNote] 노트 생성 실패:', res.status, await res.text()) alert('노트 생성 실패. 콘솔을 확인하세요.') return } const created = await res.json() console.log('[handleNewNote] 노트 생성 성공:', created) // 노트 목록 다시 로드 await loadNotes() } catch (err) { console.error('[handleNewNote] 예외 발생:', err) alert('노트 생성 중 예외 발생. 콘솔을 확인하세요.') } } // 6-3) 노트 이름 변경 const handleRenameNote = async (noteId, folderId) => { const newTitle = prompt('새 노트 이름을 입력하세요') if (!newTitle) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') console.log('[handleRenameNote] 호출됨 → noteId=', noteId, 'folderId=', folderId, ', newTitle=', newTitle) try { const res = await fetch(`${API}/api/v1/notes/${noteId}`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ title: newTitle, folder_id: folderId }) }) console.log('[handleRenameNote] 요청 바디 →', JSON.stringify({ title: newTitle, folder_id: folderId })) if (!res.ok) { console.error('[handleRenameNote] 노트 이름 변경 실패:', res.status, await res.text()) return } const updated = await res.json() console.log('[handleRenameNote] 노트 이름 변경 성공:', updated) // 노트 목록 다시 로드 await loadNotes() } catch (err) { console.error('[handleRenameNote] 예외 발생:', err) } } // 6-4) 폴더 이름 변경 const handleRenameFolder = async (folderId) => { const name = prompt('새 폴더 이름을 입력하세요') if (!name) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') console.log('[handleRenameFolder] 호출됨 → folderId=', folderId, ', newName=', name) try { const res = await fetch(`${API}/api/v1/folders/${folderId}`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ name: name }) }) console.log('[handleRenameFolder] 요청 바디 →', JSON.stringify({ name })) if (!res.ok) { console.error('[handleRenameFolder] 폴더 이름 변경 실패:', res.status, await res.text()) return } const updated = await res.json() console.log('[handleRenameFolder] 폴더 이름 변경 성공:', updated) // 폴더 목록 다시 로드 await loadFolders() } catch (err) { console.error('[handleRenameFolder] 예외 발생:', err) } } // 6-5) 노트 삭제 const handleDeleteNote = async (noteId) => { if (!confirm('이 노트를 삭제하시겠습니까?')) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') console.log('[handleDeleteNote] 호출됨 → noteId=', noteId) try { const res = await fetch(`${API}/api/v1/notes/${noteId}`, { method: 'DELETE', headers: { Authorization: `Bearer ${token}` } }) console.log('[handleDeleteNote] 요청 보냄 →', `DELETE ${API}/api/v1/notes/${noteId}`) if (!res.ok) { console.error('[handleDeleteNote] 노트 삭제 실패:', res.status, await res.text()) return } console.log('[handleDeleteNote] 노트 삭제 성공:', noteId) // 노트 목록 다시 로드 await loadNotes() } catch (err) { console.error('[handleDeleteNote] 예외 발생:', err) } } // 6-6) 폴더 삭제 const handleDeleteFolder = async (folderId) => { if (!confirm('정말 폴더를 삭제하시겠습니까?')) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') console.log('[handleDeleteFolder] 호출됨 → folderId=', folderId) try { const res = await fetch(`${API}/api/v1/folders/${folderId}`, { method: 'DELETE', headers: { Authorization: `Bearer ${token}` } }) console.log('[handleDeleteFolder] 요청 보냄 →', `DELETE ${API}/api/v1/folders/${folderId}`) if (!res.ok) { console.error('[handleDeleteFolder] 폴더 삭제 실패:', res.status, await res.text()) return } console.log('[handleDeleteFolder] 폴더 삭제 성공:', folderId) // 폴더 목록 다시 로드 await loadFolders() } catch (err) { console.error('[handleDeleteFolder] 예외 발생:', err) } } // ───────────────────────────────────────────────────────────────── // 7) 컨텍스트 메뉴 외부 클릭 시 닫기 // ───────────────────────────────────────────────────────────────── useEffect(() => { const handleClickOutside = (e) => { if (contextMenuRef.current && !contextMenuRef.current.contains(e.target)) { setFolderContextMenu({ visible: false, x: 0, y: 0, folderId: null }) setNoteContextMenu({ visible: false, x: 0, y: 0, noteId: null, folderId: null }) } } document.addEventListener('mousedown', handleClickOutside) return () => document.removeEventListener('mousedown', handleClickOutside) }, []) // ───────────────────────────────────────────────────────────────── // 8) 트리 렌더링: renderTree // ───────────────────────────────────────────────────────────────── const renderTree = (list) => list.map((node) => ( <li key={node.id}> <div className="folder-label" draggable onDragStart={(e) => { e.dataTransfer.setData('folderId', node.id) e.dataTransfer.setData('type', 'folder') console.log('[DragStart] folderId=', node.id, 'type=folder') }} onClick={() => { // ① 폴더 열기/닫기 토글 setOpenMap((prev) => ({ ...prev, [node.id]: !prev[node.id] })) // ② 부모(Layout) 컴포넌트에 선택된 폴더 ID 전달 if (onSelectFolder) onSelectFolder(node.id) // ③ URL을 "/main/:folderId"로 변경 navigate(`/main/${node.id}`) }} onContextMenu={(e) => { e.preventDefault() // 노트 컨텍스트 메뉴 숨기기 setNoteContextMenu({ visible: false, x: 0, y: 0, noteId: null, folderId: null }) // 폴더 컨텍스트 메뉴 표시 setFolderContextMenu({ visible: true, x: e.clientX, y: e.clientY, folderId: node.id }) }} onDrop={(e) => handleDrop(e, node.id)} onDragOver={(e) => e.preventDefault()} > <span>📁 {node.name}</span> </div> {openMap[node.id] && node.children.length > 0 && ( <ul className="folder-children">{renderTree(node.children)}</ul> )} {openMap[node.id] && node.notes.length > 0 && ( <ul className={`note-list ${node.parent_id ? 'nested' : 'root'}`}> {node.notes.map((n) => ( <li key={n.id} className="note-label" draggable onDragStart={(e) => { e.dataTransfer.setData('noteId', n.id) e.dataTransfer.setData('type', 'note') console.log('[DragStart] noteId=', n.id, 'type=note') }} onClick={() => { navigate(`/notes/${n.id}`) if (onNoteSelect) onNoteSelect(n.id) }} onContextMenu={(e) => { e.preventDefault() setFolderContextMenu({ visible: false, x: 0, y: 0, folderId: null }) setNoteContextMenu({ visible: true, x: e.clientX, y: e.clientY, noteId: n.id, folderId: node.id }) }} > 📝 {n.title} </li> ))} </ul> )} </li> )) return ( <aside className="sidebar"> {/* – 로고 영역 – */} <div className="sidebar-logo" style={{ cursor: 'pointer' }} onClick={() => { if (onSelectFolder) onSelectFolder(null) navigate('/main') }} > <img src="/logo.png" alt="NoteFlow Logo" className="logo-icon" /> <span className="logo-text">NoteFlow</span> </div> <div className="sidebar-controls"> {/* 최근 노트 버튼 */} <button className={activeFilter === 'recent' ? 'active' : ''} onClick={() => { setActiveFilter('recent') onFilterChange('recent') if (onSelectFolder) onSelectFolder(null) navigate('/main') }} > 최근 노트 </button> {/* 내 폴더 섹션 */} <div className="folder-section"> <button className={activeFilter === 'all' ? 'active' : ''} onClick={() => { setActiveFilter('all') onFilterChange('all') if (onSelectFolder) onSelectFolder(null) navigate('/main') }} > 내 폴더 </button> {activeFilter === 'all' && ( <ul className="folder-list"> {treeFolders.length === 0 ? ( <li style={{ color: '#777', padding: '0.5rem 1rem' }}>폴더가 없습니다.</li> ) : ( renderTree(treeFolders) )} </ul> )} </div> {/* 즐겨찾기 버튼 */} <button className={activeFilter === 'favorites' ? 'active' : ''} onClick={() => { setActiveFilter('favorites') onFilterChange('favorites') if (onSelectFolder) onSelectFolder(null) navigate('/main') }} > 즐겨찾기 </button> </div> {/* 폴더 컨텍스트 메뉴 */} {folderContextMenu.visible && ( <div className="context-menu" style={{ top: folderContextMenu.y, left: folderContextMenu.x, position: 'fixed', zIndex: 1000 }} ref={contextMenuRef} > <div onClick={() => { handleNewNote(folderContextMenu.folderId) setFolderContextMenu({ visible: false, x: 0, y: 0, folderId: null }) }}>➕ 새 노트</div> <div onClick={() => { handleNewFolder(folderContextMenu.folderId) setFolderContextMenu({ visible: false, x: 0, y: 0, folderId: null }) }}>➕ 새 폴더</div> <div onClick={() => { handleRenameFolder(folderContextMenu.folderId) setFolderContextMenu({ visible: false, x: 0, y: 0, folderId: null }) }}>✏️ 이름 변경</div> <div onClick={() => { handleDeleteFolder(folderContextMenu.folderId) setFolderContextMenu({ visible: false, x: 0, y: 0, folderId: null }) }}>🗑️ 폴더 삭제</div> </div> )} {/* 노트 컨텍스트 메뉴 */} {noteContextMenu.visible && ( <div className="context-menu" style={{ top: noteContextMenu.y, left: noteContextMenu.x, position: 'fixed', zIndex: 1000 }} ref={contextMenuRef} > <div onClick={() => { handleRenameNote(noteContextMenu.noteId, noteContextMenu.folderId) setNoteContextMenu({ visible: false, x: 0, y: 0, noteId: null, folderId: null }) }}>✏️ 이름 변경</div> <div onClick={() => { handleDeleteNote(noteContextMenu.noteId) setNoteContextMenu({ visible: false, x: 0, y: 0, noteId: null, folderId: null }) }}>🗑️ 노트 삭제</div> </div> )} </aside> ) } // src/components/Topbar.jsx import React, { useState, useEffect, useRef } from 'react' import { useNavigate } from 'react-router-dom' import '../css/Topbar.css' export default function TopBar({ onNewNote, currentNote, onToggleFavorite }) { const [query, setQuery] = useState('') const [results, setResults] = useState([]) const [showSettings, setShowSettings] = useState(false) const btnRef = useRef(null) const navigate = useNavigate() useEffect(() => { const onClickOutside = e => { if (btnRef.current && !btnRef.current.contains(e.target)) { setShowSettings(false) } } document.addEventListener('mousedown', onClickOutside) return () => document.removeEventListener('mousedown', onClickOutside) }, []) useEffect(() => { if (!query.trim()) { setResults([]) return } fetch(`${import.meta.env.VITE_API_BASE_URL}/api/v1/notes`, { headers: { Authorization: `Bearer ${localStorage.getItem('access_token')}` } }) .then(res => res.ok ? res.json() : Promise.reject()) .then(data => { const filtered = data.filter(n => n.title.toLowerCase().includes(query.toLowerCase()) ) setResults(filtered) }) .catch(err => { console.error('노트 검색 실패:', err) }) }, [query]) return ( <header className="topbar"> <div className="topbar-left"> <button className="topbar-new" onClick={onNewNote}>+ 새 노트</button> <div className="search-container"> <input className="topbar-search" type="text" placeholder="🔍 노트 제목 검색" value={query} onChange={e => setQuery(e.target.value)} /> {results.length > 0 && ( <ul className="search-results"> {results.slice(0, 5).map(note => ( <li key={note.id} onClick={() => { navigate(`/notes/${note.id}`) setQuery('') setResults([]) }} > 📝 {note.title} </li> ))} </ul> )} </div> </div> <div className="topbar-actions"> {currentNote && ( <button className="topbar-fav" onClick={onToggleFavorite} aria-label="즐겨찾기" > {currentNote.is_favorite ? '⭐' : '☆'} </button> )} <button ref={btnRef} className="topbar-settings" onClick={() => setShowSettings(prev => !prev)} aria-label="설정" > ⋯ </button> {showSettings && ( <div className="settings-menu"> <input className="settings-search" type="text" placeholder="작업 검색..." /> <div className="settings-item">링크 복사</div> <div className="settings-item disabled">옮기기</div> <div className="settings-item toggle"> 작은 텍스트 <label className="switch"> <input type="checkbox" /> <span className="slider" /> </label> </div> </div> )} </div> </header> ) } // src/screen/KakaoCallback.jsx import { useEffect } from 'react'; import { useNavigate, useSearchParams } from 'react-router-dom'; export default function KakaoCallback() { const navigate = useNavigate(); const [searchParams] = useSearchParams(); useEffect(() => { const code = searchParams.get('code'); console.log('Kakao code:', code); if (!code) { alert('카카오 로그인 실패: code 없음'); return; } fetch('http://222.116.135.71:8080/api/v1/auth/kakao/callback', { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded', }, body: new URLSearchParams({ code }), // ✅ form-encoded 방식 }) .then((res) => res.json().then(data => ({ status: res.status, data }))) .then(({ status, data }) => { if (status === 200 && data.user_id && data.access_token) { localStorage.setItem('access_token', data.access_token); navigate('/main'); } else { alert(data.message || '카카오 로그인 실패'); } }) .catch(() => alert('서버 연결 실패')); }, [navigate, searchParams]); return <div>카카오 로그인 처리 중입니다...</div>; } import React, { useState, useRef } from 'react'; import { useNavigate } from 'react-router-dom'; import '../css/Login.css'; import { GoogleOAuthProvider, GoogleLogin } from '@react-oauth/google'; export default function LoginPage() { const navigate = useNavigate(); const [username, setUsername] = useState(''); const [password, setPassword] = useState(''); const googleLoginBtnRef = useRef(null); const handleLogin = async (e) => { e.preventDefault(); try { const response = await fetch(import.meta.env.VITE_API_BASE_URL + '/api/v1/login', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ loginId: username, password }) }); const data = await response.json(); if (response.ok) { localStorage.setItem('access_token', data.access_token); navigate('/main'); } else { alert(data.message || '로그인 실패'); } } catch (err) { alert('서버와의 연결에 실패했습니다.'); } }; const handleSocialLogin = (provider) => { if (provider === 'google') { if (googleLoginBtnRef.current) { const googleButton = googleLoginBtnRef.current.querySelector('div[role="button"]'); if (googleButton) googleButton.click(); } } else if (provider === 'naver') { const clientId = import.meta.env.VITE_NAVER_CLIENT_ID; const redirectUri = import.meta.env.VITE_NAVER_REDIRECT_URI; const state = Math.random().toString(36).substring(2, 15); window.location.href = `https://nid.naver.com/oauth2.0/authorize?response_type=code&client_id=${clientId}&redirect_uri=${redirectUri}&state=${state}`; } else if (provider === 'kakao') { const kakaoClientId = import.meta.env.VITE_KAKAO_CLIENT_ID; const kakaoRedirectUri = 'http://localhost:5174/kakao/callback'; const kakaoAuthUrl = `https://kauth.kakao.com/oauth/authorize?client_id=${kakaoClientId}&redirect_uri=${kakaoRedirectUri}&response_type=code`; window.location.href = kakaoAuthUrl; } else { alert(`${provider} 로그인은 아직 구현되지 않았습니다.`); } }; return ( <GoogleOAuthProvider clientId={import.meta.env.VITE_GOOGLE_CLIENT_ID}> <div className="login-container"> <div className="login-box"> <div className="login-logo-box"> <img src="/logo.png" alt="NoteFlow Logo" className="login-logo-img" /> <h1 className="login-logo-text">NoteFlow</h1> </div> <form className="login-form" onSubmit={handleLogin}> <input type="text" placeholder="아이디" className="login-input" value={username} onChange={(e) => setUsername(e.target.value)} /> <input type="password" placeholder="비밀번호" className="login-input" value={password} onChange={(e) => setPassword(e.target.value)} /> <button type="submit" className="login-btn">로그인</button> </form> <div className="login-social-login"> <button className="login-circle-btn login-kakao-btn"> <img src="/kakao-icon.svg" alt="Kakao" className="login-kakao-icon" onClick={() => handleSocialLogin('kakao')} /> </button> <button className="login-circle-btn login-naver-btn"> <img src="/naver-icon.png" alt="Naver" className="login-naver-icon" onClick={() => handleSocialLogin('naver')} /> </button> <button className="login-circle-btn login-google-btn"> <img src="/google-icon.svg" alt="Google" className="login-google-icon" onClick={() => handleSocialLogin('google')} /> </button> </div> <div style={{ position: 'absolute', left: '-9999px' }} ref={googleLoginBtnRef}> <GoogleLogin onSuccess={async (response) => { const token = response.credential; const res = await fetch(import.meta.env.VITE_API_BASE_URL + '/api/v1/login/google', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token }) }); const data = await res.json(); if (res.ok) { localStorage.setItem('access_token', data.access_token); navigate('/main'); } else { alert(data.message || '구글 로그인 실패'); } }} onError={() => alert('구글 로그인 실패')} useOneTap={false} /> </div> <div className="login-signup-text"> 계정이 없으신가요?{' '} <a onClick={() => navigate('/signup')} style={{ cursor: 'pointer' }}> 회원가입 </a> </div> </div> </div> </GoogleOAuthProvider> ); } // src/screen/Main.jsx import React, { useState, useEffect, useCallback } from 'react' import { useNavigate, useOutletContext, useParams } from 'react-router-dom' import '../css/Main.css' export default function MainPage() { const navigate = useNavigate() // URL 파라미터 :folderId const { folderId } = useParams() const parsedFolderId = folderId ? parseInt(folderId, 10) : null // Layout에서 내려준 context const { filter, // 'all' | 'recent' | 'favorites' fileUploadTimestamp, // 업로드 시마다 갱신되는 timestamp } = useOutletContext() // 상태: 노트 목록, 파일 목록, 그리고 폴더명 const [notes, setNotes] = useState([]) const [files, setFiles] = useState([]) const [folderName, setFolderName] = useState('') // 드래그 오버 상태 (true면 배경색 강조) const [isDragOver, setIsDragOver] = useState(false) const token = localStorage.getItem('access_token') const API = import.meta.env.VITE_API_BASE_URL // ──────────────────────────────────────────────────────────────── // 1) 폴더명 가져오기 (parsedFolderId 변경 시) // ──────────────────────────────────────────────────────────────── useEffect(() => { if (!parsedFolderId) { setFolderName('') return } fetch(`${API}/api/v1/folders`, { headers: { Authorization: `Bearer ${token}` } }) .then((res) => { if (!res.ok) throw new Error('폴더 목록 불러오기 실패') return res.json() }) .then((data) => { const found = data.find((f) => f.id === parsedFolderId) setFolderName(found ? found.name : '') }) .catch((err) => { console.error('폴더명 가져오기 실패:', err) setFolderName('') }) }, [parsedFolderId, API, token]) // ──────────────────────────────────────────────────────────────── // 2) 노트 목록 가져오기 (filter, parsedFolderId 변경 시) // ──────────────────────────────────────────────────────────────── useEffect(() => { if (!parsedFolderId) { let url = filter === 'recent' ? '/api/v1/notes/recent' : '/api/v1/notes' fetch(`${API}${url}`, { headers: { Authorization: `Bearer ${token}` } }) .then((res) => { if (!res.ok) throw new Error('노트 불러오기 실패') return res.json() }) .then((data) => { if (filter === 'favorites') { setNotes(data.filter((n) => n.is_favorite)) } else { setNotes(data) } }) .catch((err) => { console.error('노트 불러오기 실패:', err) setNotes([]) }) setFiles([]) } else { fetch(`${API}/api/v1/notes`, { headers: { Authorization: `Bearer ${token}` } }) .then((res) => { if (!res.ok) throw new Error('노트 불러오기 실패') return res.json() }) .then((data) => { const filteredNotes = data.filter((n) => n.folder_id === parsedFolderId) setNotes(filteredNotes) }) .catch((err) => { console.error('폴더 내 노트 불러오기 실패:', err) setNotes([]) }) } }, [filter, parsedFolderId, API, token]) // ──────────────────────────────────────────────────────────────── // 3) 파일 목록 가져오기 (parsedFolderId, fileUploadTimestamp 변경 시) // ──────────────────────────────────────────────────────────────── const fetchFiles = useCallback(() => { if (parsedFolderId !== null) { fetch(`${API}/api/v1/files/list/${parsedFolderId}`, { headers: { Authorization: `Bearer ${token}` } }) .then((res) => { if (!res.ok) throw new Error('파일 목록 불러오기 실패') return res.json() }) .then((data) => { setFiles(data) }) .catch((err) => { console.error('폴더 내 파일 목록 불러오기 실패:', err) setFiles([]) }) } else { setFiles([]) } }, [parsedFolderId, API, token]) useEffect(() => { fetchFiles() }, [fetchFiles, fileUploadTimestamp]) // ──────────────────────────────────────────────────────────────── // 4) 드래그 앤 드롭: 파일 드롭 이벤트 처리 + 시각 피드백 // ──────────────────────────────────────────────────────────────── const handleDragOver = (e) => { e.preventDefault() } const handleDragEnter = (e) => { e.preventDefault() setIsDragOver(true) } const handleDragLeave = (e) => { e.preventDefault() setIsDragOver(false) } const handleFileDrop = async (e) => { e.preventDefault() setIsDragOver(false) if (parsedFolderId === null) { alert('먼저 업로드할 폴더를 선택하세요.') return } const droppedFiles = e.dataTransfer.files if (!droppedFiles || droppedFiles.length === 0) return for (let i = 0; i < droppedFiles.length; i++) { const file = droppedFiles[i] const formData = new FormData() formData.append('upload_file', file) formData.append('folder_id', parsedFolderId) console.log(`[handleFileDrop] 파일 업로드 요청 → "${file.name}" → 폴더 ${parsedFolderId}`) try { const res = await fetch(`${API}/api/v1/files/upload`, { method: 'POST', headers: { Authorization: `Bearer ${token}` }, body: formData }) if (!res.ok) { console.error(`[handleFileDrop] 업로드 실패: "${file.name}"`, res.status, await res.text()) } else { console.log(`[handleFileDrop] 업로드 성공: "${file.name}"`) } } catch (err) { console.error(`[handleFileDrop] 예외 발생: "${file.name}"`, err) } } // 업로드 완료 후 즉시 목록 갱신 fetchFiles() } // ──────────────────────────────────────────────────────────────── // 5) 화면 렌더링: 폴더 선택 여부에 따라 노트 & 파일 분리 표시 // ──────────────────────────────────────────────────────────────── return ( <main className="main-content" style={{ padding: '1rem' }}> {/* ──────────────────────────────────────────────────────────────── */} {/* 5-1) parsedFolderId가 null → 전체/최근/즐겨찾기 노트만 표시 */} {/* ──────────────────────────────────────────────────────────────── */} {parsedFolderId === null && ( <section className="main-note-list"> {notes.map((note) => ( <div key={note.id} className="main-note-item" draggable onDragStart={(e) => { e.dataTransfer.setData('noteId', note.id) e.dataTransfer.setData('type', 'note') }} onClick={() => navigate(`/notes/${note.id}`)} > <h3 className="main-note-title">{note.title}</h3> <p className="main-note-preview"> {note.content?.slice(0, 100) || ''} </p> <span className="main-note-date"> {new Date(note.created_at).toLocaleDateString()} </span> </div> ))} </section> )} {/* ──────────────────────────────────────────────────────────────── */} {/* 5-2) parsedFolderId가 숫자 → 해당 폴더 ID 내 노트 & 파일 표시 */} {/* ──────────────────────────────────────────────────────────────── */} {parsedFolderId !== null && ( <> {/* 5-2-1) 헤더: “📂 {폴더명}” */} <h2 style={{ fontSize: '1.5rem', marginBottom: '0.75rem' }}> 📂 {folderName || `폴더 #${parsedFolderId}`} </h2> {/* 5-2-2) 폴더 내 노트 섹션 */} <section className="main-note-list"> {notes.length === 0 ? ( <p style={{ color: '#777' }}>이 폴더에는 노트가 없습니다.</p> ) : ( notes.map((note) => ( <div key={note.id} className="main-note-item" draggable onDragStart={(e) => { e.dataTransfer.setData('noteId', note.id) e.dataTransfer.setData('type', 'note') }} onClick={() => navigate(`/notes/${note.id}`)} > <h3 className="main-note-title">{note.title}</h3> <p className="main-note-preview"> {note.content?.slice(0, 100) || ''} </p> <span className="main-note-date"> {new Date(note.created_at).toLocaleDateString()} </span> </div> )) )} </section> {/* 5-2-3) 구분선 */} <hr style={{ margin: '1.5rem 0', borderColor: '#ddd' }} /> {/* 5-2-4) 폴더 내 파일 섹션 (드래그 앤 드롭 허용) */} <h3 style={{ marginBottom: '0.5rem' }}> 📁 업로드된 파일 ({files.length}) </h3> <section className={`main-file-list ${` isDragOver ? 'drag-over' : '' }`}` onDragEnter={handleDragEnter} onDragOver={handleDragOver} onDragLeave={handleDragLeave} onDrop={handleFileDrop} style={{ minHeight: '150px' }} > {files.length === 0 ? ( <p style={{ color: '#777' }}>이 폴더에는 업로드된 파일이 없습니다.</p> ) : ( <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}> {files.map((f) => ( <li key={f.file_id} className="main-file-item" onClick={() => { // 클릭 시 미리보기/다운로드 (새 탭) window.open( `${API}/api/v1/files/download/${f.file_id}`, '_blank' ) }} style={{ display: 'flex', alignItems: 'center', padding: '0.75rem', borderBottom: '1px solid #e8e8e8', cursor: 'pointer', transition: 'background 0.15s ease', }} onMouseEnter={(e) => (e.currentTarget.style.background = '#f9f9f9')} onMouseLeave={(e) => (e.currentTarget.style.background = 'transparent')} > {/* 간단한 파일 아이콘 */} <div style={{ width: '32px', height: '32px', background: '#f0f0f0', borderRadius: '4px', display: 'flex', alignItems: 'center', justifyContent: 'center', marginRight: '0.75rem', fontSize: '1.2rem', }} > 📄 </div> <div style={{ display: 'flex', flexDirection: 'column' }}> <span style={{ fontSize: '1rem', color: '#333' }}> {f.original_name} </span> <span style={{ fontSize: '0.85rem', color: '#555' }}> {new Date(f.created_at).toLocaleDateString()} </span> </div> </li> ))} </ul> )} {/* <div style={{ textAlign: 'center', color: '#999', marginTop: '1rem' }}> 파일을 이 영역으로 드래그 앤 드롭하면 바로 업로드됩니다. </div> */} </section> </> )} </main> ) } // src/screen/NaverCallback.jsx import { useEffect } from 'react'; import { useNavigate, useSearchParams } from 'react-router-dom'; export default function NaverCallback() { const navigate = useNavigate(); const [searchParams] = useSearchParams(); useEffect(() => { const code = searchParams.get('code'); const state = searchParams.get('state'); if (code && state) { fetch('http://222.116.135.71:8080/api/v1/login/naver', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ code, state }), }) .then((res) => res.json()) .then((data) => { if (data.user_id) { navigate('/main'); } else { alert(data.message || '네이버 로그인 실패'); } }) .catch(() => alert('서버 연결 실패')); } }, [navigate, searchParams]); return <div>네이버 로그인 처리 중...</div>; } import React, { useState } from 'react' import { useNavigate } from 'react-router-dom' import '../css/NewNote.css' export default function NewNotePage() { const navigate = useNavigate() const [title, setTitle] = useState('') const [content, setContent] = useState('') const handleSave = async (e) => { e.preventDefault() try { const res = await fetch( `${import.meta.env.VITE_API_BASE_URL}/api/v1/notes`, { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${localStorage.getItem('access_token')}` }, body: JSON.stringify({ title, content }) } ) if (res.ok) navigate('/main') else { const { detail } = await res.json() alert(detail || '노트 생성 실패') } } catch { alert('서버 연결 실패') } } return ( <div className="newnote-container"> <form className="newnote-form" onSubmit={handleSave}> <input type="text" placeholder="제목" value={title} onChange={e => setTitle(e.target.value)} className="newnote-title" /> <textarea placeholder="내용을 입력하세요" value={content} onChange={e => setContent(e.target.value)} className="newnote-content" /> <div className="newnote-actions"> <button type="submit" className="newnote-save-btn">저장</button> <button type="button" className="newnote-cancel-btn" onClick={() => navigate('/main')} > 취소 </button> </div> </form> </div> ) } // src/screen/NoteDetail.jsx import React, { useState, useEffect, useRef } from 'react' import { useParams, useNavigate, useOutletContext } from 'react-router-dom' import { Editor } from '@toast-ui/react-editor' import '@toast-ui/editor/dist/toastui-editor.css' export default function NoteDetail() { const { id } = useParams() const navigate = useNavigate() const editorRef = useRef() const [note, setNote] = useState(null) const [saving, setSaving] = useState(false) const [summarizing, setSummarizing] = useState(false) const { setCurrentNote } = useOutletContext() // 업로드된 파일 목록 상태 const [files, setFiles] = useState([]) // 미리보기 상태 (URL, MIME 타입, 파일명) const [previewUrl, setPreviewUrl] = useState(null) const [previewType, setPreviewType] = useState(null) const [previewName, setPreviewName] = useState(null) const token = localStorage.getItem('access_token') // 1) 노트 데이터 로드 useEffect(() => { fetch(`${import.meta.env.VITE_API_BASE_URL}/api/v1/notes/${id}`, { headers: { Authorization: `Bearer ${token}` } }) .then(res => (res.ok ? res.json() : Promise.reject())) .then(data => { setNote(data) setCurrentNote(data) }) .catch(() => { alert('노트를 불러올 수 없습니다.') navigate('/main') }) }, [id, navigate, setCurrentNote, token]) // 2) 업로드된 파일 목록 로드 useEffect(() => { if (!note) return const folderId = note.folder_id if (!folderId) { setFiles([]) return } fetch(`${import.meta.env.VITE_API_BASE_URL}/api/v1/files/list/${folderId}`, { headers: { Authorization: `Bearer ${token}` } }) .then(res => (res.ok ? res.json() : Promise.reject())) .then(data => { setFiles(data) }) .catch(() => { console.error('파일 목록을 불러오는 데 실패했습니다.') setFiles([]) }) }, [note, token]) // 3) typeWriter 함수 function typeWriter(editorRef, fullText, speed = 25, done = () => {}) { const inst = editorRef.current?.getInstance() if (!inst) return let i = 0 inst.setMarkdown('') inst.focus() const step = () => { i += 1 inst.setMarkdown(fullText.slice(0, i)) if (i < fullText.length) { setTimeout(step, speed) } else { done() } } step() } if (!note) return null // 4) 노트 저장 핸들러 const handleSave = async () => { const content = editorRef.current.getInstance().getMarkdown() setSaving(true) try { const res = await fetch( `${import.meta.env.VITE_API_BASE_URL}/api/v1/notes/${id}`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ title: note.title, content, folder_id: note.folder_id }) } ) if (!res.ok) throw new Error('Save failed') const updated = await res.json() setNote(updated) setCurrentNote(updated) alert('저장되었습니다.') } catch { alert('저장에 실패했습니다.') } finally { setSaving(false) } } // 5) 노트 요약 핸들러 const handleSummarize = async () => { setSummarizing(true) try { const res = await fetch( `${import.meta.env.VITE_API_BASE_URL}/api/v1/notes/${id}/summarize`, { method: 'POST', headers: { Authorization: `Bearer ${token}` } } ) if (!res.ok) throw new Error('Summarize failed') const updated = await res.json() setNote(updated) setCurrentNote(updated) setTimeout(() => { typeWriter(editorRef, updated.content ?? '', 20, () => setSummarizing(false)) }, 150) } catch { alert('요약에 실패했습니다.') setSummarizing(false) } } // 6) 파일 클릭 시 미리보기 핸들러 const handleFileClick = async (file_id, original_name, content_type) => { try { // 인증 없이 열리는 엔드포인트 호출 const res = await fetch( `${import.meta.env.VITE_API_BASE_URL}/api/v1/files/download/${file_id}` ) if (!res.ok) { console.error('파일 로드 실패', res.status, await res.text()) return } const blob = await res.blob() const url = window.URL.createObjectURL(blob) setPreviewUrl(url) setPreviewType(content_type) setPreviewName(original_name) } catch (err) { console.error('미리보기 중 예외', err) } } // 7) 미리보기 닫기 const closePreview = () => { if (previewUrl) window.URL.revokeObjectURL(previewUrl) setPreviewUrl(null) setPreviewType(null) setPreviewName(null) } return ( <div className="main-container"> <main className="main-content" style={{ padding: '1rem' }}> {/* 노트 제목 + 버튼 */} <div style={{ display: 'flex', alignItems: 'center', gap: '1rem', marginBottom: '1rem' }} > <h1 style={{ flex: 1, fontSize: '1.5rem', margin: 0 }}> {note.title} </h1> <button onClick={handleSave} disabled={saving} style={{ padding: '0.6rem 1.2rem', background: saving ? '#ccc' : '#007aff', color: '#fff', border: 'none', borderRadius: '0.4rem' }} > {saving ? '저장중…' : '💾 저장'} </button> <button onClick={handleSummarize} disabled={summarizing} style={{ padding: '0.6rem 1.2rem', background: summarizing ? '#ccc' : '#28a745', color: '#fff', border: 'none', borderRadius: '0.4rem' }} > {summarizing ? '요약중…' : '🧠 요약'} </button> </div> {/* 토스트UI 에디터 */} <Editor key={id} ref={editorRef} initialValue={note.content ?? ''} previewStyle="vertical" height="600px" initialEditType="markdown" useCommandShortcut={true} /> {/* 업로드된 파일 목록 */} <div style={{ marginTop: '2rem' }}> <h3 style={{ marginBottom: '0.5rem' }}> 🗂️ 업로드된 파일 ({files.length}) </h3> <ul style={{ listStyle: 'none', paddingLeft: 0, margin: 0 }}> {files.map(f => ( <li key={f.file_id} style={{ display: 'flex', flexDirection: 'column', padding: '0.75rem 1rem', marginBottom: '0.5rem', background: '#f9f9f9', borderRadius: '0.4rem', cursor: 'pointer', transition: 'background 0.2s' }} onClick={() => handleFileClick(f.file_id, f.original_name, f.content_type) } onMouseOver={e => (e.currentTarget.style.background = '#eef')} onMouseOut={e => (e.currentTarget.style.background = '#f9f9f9')} > <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}> {/* 파일 아이콘 */} <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#555" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" > <path d="M14 2H6a2 2 0 0 0-2 2v16c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V8z" /> <polyline points="14 2 14 8 20 8" /> </svg> <span style={{ fontSize: '1rem', color: '#333' }}> {f.original_name} </span> </div> <small style={{ color: '#777', marginTop: '0.25rem' }}> {new Date(f.created_at).toLocaleString()} </small> </li> ))} </ul> </div> {/* 미리보기 모달 (다운로드 기능 없음) */} {previewUrl && ( <div style={{ position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh', background: 'rgba(0, 0, 0, 0.6)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }} onClick={closePreview} > <div style={{ position: 'relative', width: '80%', maxWidth: '900px', height: '80%', background: '#fff', borderRadius: '0.4rem', overflow: 'hidden', boxShadow: '0 2px 10px rgba(0,0,0,0.3)' }} onClick={e => e.stopPropagation()} > {/* 닫기 버튼 */} <button onClick={closePreview} style={{ position: 'absolute', top: '0.5rem', right: '0.5rem', background: 'transparent', border: 'none', fontSize: '1.5rem', cursor: 'pointer' }} > × </button> {/* 이미지 미리보기 */} {previewType.startsWith('image/') && ( <img src={previewUrl} alt={previewName} style={{ width: '100%', height: '100%', objectFit: 'contain', background: '#000' }} /> )} {/* PDF 미리보기 */} {previewType === 'application/pdf' && ( <iframe src={previewUrl} title={previewName} style={{ width: '100%', height: '100%', border: 'none' }} /> )} {/* 그 외 파일: 미리보기 없음 메시지 */} {!previewType.startsWith('image/') && previewType !== 'application/pdf' && ( <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', flexDirection: 'column', padding: '1rem', textAlign: 'center' }} > <p style={{ color: '#333' }}> 미리보기를 지원하지 않는 파일 형식입니다. </p> </div> )} </div> </div> )} </main> </div> ) } // src/screen/Signup.jsx import React, { useState } from 'react' import '../css/Signup.css' import { useNavigate } from 'react-router-dom' export default function SignupPage() { const navigate = useNavigate() const [loginId, setLoginId] = useState('') const [password, setPassword] = useState('') const [confirmPw, setConfirmPw] = useState('') const [email, setEmail] = useState('') const handleSignup = async (e) => { e.preventDefault() if (password !== confirmPw) { alert('비밀번호가 일치하지 않습니다') return } try { const res = await fetch( `${import.meta.env.VITE_API_BASE_URL}/api/v1/register`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ loginId, email, password }) } ) const data = await res.json() if (res.ok) { navigate('/') } else { alert(data.detail || data.message || '회원가입 실패') } } catch { alert('서버 연결에 실패했습니다.') } } return ( <div className="signup-container"> <div className="signup-box"> <div className="signup-logo-box"> <img src="/logo.png" alt="NoteFlow Logo" className="signup-logo-img" /> <h1 className="signup-logo-text">NoteFlow</h1> </div> <form className="signup-form" onSubmit={handleSignup}> <input type="text" placeholder="아이디" className="signup-input" value={loginId} onChange={e => setLoginId(e.target.value)} /> <input type="password" placeholder="비밀번호" className="signup-input" value={password} onChange={e => setPassword(e.target.value)} /> <input type="password" placeholder="비밀번호 확인" className="signup-input" value={confirmPw} onChange={e => setConfirmPw(e.target.value)} /> <input type="email" placeholder="이메일" className="signup-input" value={email} onChange={e => setEmail(e.target.value)} /> <button type="submit" className="signup-signup-btn"> 회원가입 </button> </form> <div className="signup-social-login"> <button className="signup-circle-btn signup-kakao-btn"> <img src="/kakao-icon.svg" alt="Kakao" className="signup-kakao-icon" /> </button> <button className="signup-circle-btn signup-naver-btn"> <img src="/naver-icon.png" alt="Naver" className="signup-naver-icon" /> </button> <button className="signup-circle-btn signup-google-btn"> <img src="/google-icon.svg" alt="Google" className="signup-google-icon" /> </button> </div> <div className="signup-login-text"> 이미 계정이 있으신가요?{' '} <span className="signup-login-link" onClick={() => navigate('/')} > 로그인 </span> </div> </div> </div> ) } // src/App.tsx import React from 'react' import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom' import LoginPage from './screen/Login' import SignupPage from './screen/Signup' import MainPage from './screen/Main' import Layout from './components/Layout' import NewNotePage from './screen/NewNotePage' import NoteDetail from './screen/NoteDetail' import NaverCallback from './screen/NaverCallback' import KakaoCallback from './screen/KakaoCallback' import './App.css' const App: React.FC = () => ( <BrowserRouter> <Routes> {/* --- 인증 관련 (로그인/회원가입/소셜 콜백) --- */} <Route path="/" element={<LoginPage />} /> <Route path="/signup" element={<SignupPage />} /> <Route path="/naver/callback" element={<NaverCallback />} /> <Route path="/kakao/callback" element={<KakaoCallback />} /> {/* --- Layout 하위 라우팅 --- */} <Route element={<Layout />}> {/* 1) 폴더 미선택(전체/최근/즐겨찾기) */} <Route path="/main" element={<MainPage />} /> {/* 2) 폴더 선택 상태 (URL에 folderId가 붙음) */} <Route path="/main/:folderId" element={<MainPage />} /> {/* 새 노트 생성 */} <Route path="/notes/new" element={<NewNotePage />} /> {/* 노트 상세 보기 */} <Route path="/notes/:id" element={<NoteDetail />} /> </Route> {/* --- 그 외 모든 경로는 로그인으로 리다이렉트 --- */} <Route path="*" element={<Navigate to="/" replace />} /> </Routes> </BrowserRouter> ) export default App import React from 'react'; import ReactDOM from 'react-dom/client'; import App from './App'; import { GoogleOAuthProvider } from '@react-oauth/google'; const rootElement = document.getElementById('root'); if (!rootElement) throw new Error("root element not found"); ReactDOM.createRoot(rootElement).render( <GoogleOAuthProvider clientId={import.meta.env.VITE_GOOGLE_CLIENT_ID}> <React.StrictMode> <App /> </React.StrictMode> </GoogleOAuthProvider> );

###### ChatGPT의 말:

Something went wrong, please try reloading the conversation.

  

ChatGPT는 실수를 할 수 있습니다. OpenAI에서는 AI야생동물행동생태제어기초연구실 워크스페이스 데이터를 이용해 모델을 훈련하지 않습니다.