## ì±„íŒ… ê¸°ë¡

[](https://chatgpt.com/)

##### ë‚˜ì˜ ë§:

ì½”ë“œ ì´í•´ë¶€í„° í•˜ì 1. ë°±ì—”ë“œ ì½”ë“œë¥¼ ë¨¼ì € ë³´ì—¬ì¤„ê²Œ íŒŒì¼êµ¬ì¡°ë‘ 2. í”„ë¡ íŠ¸ ì½”ë“œë‘ íŒŒì¼êµ¬ì¡°ë¥¼ ë³´ì—¬ì¤„ê²Œ 3. ë‚´ê°€ ì—ëŸ¬ë¥¼ ë³´ì—¬ì¤„í…Œë‹ˆ ì–´ë–¤ê²Œ ë¬¸ì œì¸ì§€ í•´ê²°í•´ì„œ ì „ì²´ ì½”ë“œë¥¼ ë³´ì—¬ì¤˜

###### ChatGPTì˜ ë§:

ë„¤, ì•Œê² ìŠµë‹ˆë‹¤. ë¨¼ì € ë°±ì—”ë“œ ì½”ë“œì™€ íŒŒì¼ êµ¬ì¡°ë¥¼ ê³µìœ í•´ ì£¼ì‹œë©´, ìì„¸íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

##### ë‚˜ì˜ ë§:

# 
Backend/models/file.py from sqlalchemy import Column, Integer, String, ForeignKey, TIMESTAMP, text from .base import Base class File(Base): __tablename__ = 'file' id = Column(Integer, primary_key=True, autoincrement=True) user_id = Column(Integer, ForeignKey('user.u_id', ondelete='CASCADE'), nullable=False) folder_id = Column(Integer, ForeignKey('folder.id', ondelete='SET NULL'), nullable=True) original_name = Column(String(255), nullable=False) # ìœ ì €ê°€ ì—…ë¡œë“œí•œ ì›ë³¸ íŒŒì¼ ì´ë¦„ saved_path = Column(String(512), nullable=False) # ì„œë²„ì— ì €ì¥ëœ(ì‹¤ì œ) ê²½ë¡œ content_type = Column(String(100), nullable=False) # MIME íƒ€ì… created_at = Column(TIMESTAMP, nullable=False, server_default=text('CURRENT_TIMESTAMP')) from sqlalchemy import Column, Integer, String, ForeignKey, TIMESTAMP, text from .base import Base class Folder(Base): __tablename__ = 'folder' id = Column(Integer, primary_key=True, autoincrement=True) user_id = Column(Integer, ForeignKey('user.u_id', ondelete='CASCADE'), nullable=False) name = Column(String(100), nullable=False) parent_id = Column(Integer, ForeignKey('folder.id', ondelete='SET NULL'), nullable=True) created_at = Column(TIMESTAMP, nullable=False, server_default=text('CURRENT_TIMESTAMP')) updated_at = Column(TIMESTAMP, nullable=False, server_default=text('CURRENT_TIMESTAMP'), onupdate=text('CURRENT_TIMESTAMP')) from sqlalchemy import Column, Integer, String, Text, Boolean, ForeignKey, TIMESTAMP, text from .base import Base class Note(Base): __tablename__ = 'note' id = Column(Integer, primary_key=True, autoincrement=True) user_id = Column(Integer, ForeignKey('user.u_id', ondelete='CASCADE'), nullable=False) folder_id = Column(Integer, ForeignKey('folder.id', ondelete='SET NULL'), nullable=True) title = Column(String(255), nullable=False) content = Column(Text) is_favorite = Column(Boolean, nullable=False, server_default=text('FALSE')) last_accessed = Column(TIMESTAMP, nullable=True) created_at = Column(TIMESTAMP, nullable=False, server_default=text('CURRENT_TIMESTAMP')) updated_at = Column(TIMESTAMP, nullable=False, server_default=text('CURRENT_TIMESTAMP'), onupdate=text('CURRENT_TIMESTAMP')) from sqlalchemy import Column, Integer, String, Enum, TIMESTAMP, text from .base import Base class User(Base): __tablename__ = 'user' u_id = Column(Integer, primary_key=True, autoincrement=True) id = Column(String(50), nullable=False, unique=True) email = Column(String(150), nullable=False, unique=True) password = Column(String(255), nullable=False) provider = Column( Enum('local','google','kakao','naver', name='provider_enum'), nullable=False, server_default=text("'local'") ) created_at = Column(TIMESTAMP, nullable=False, server_default=text('CURRENT_TIMESTAMP')) updated_at = Column(TIMESTAMP, nullable=False, server_default=text('CURRENT_TIMESTAMP'), onupdate=text('CURRENT_TIMESTAMP')) # routers/auth.py from fastapi import APIRouter, Depends, HTTPException, Form from sqlalchemy.orm import Session import os, requests from db import get_db from models.user import User from schemas.user import ( RegisterRequest, RegisterResponse, LoginRequest, LoginResponse, GoogleLoginRequest, NaverLoginRequest, KakaoLoginRequest ) from utils.password import hash_password, verify_password from utils.jwt_utils import create_access_token from google.oauth2 import id_token from google.auth.transport import requests as grequests import logging from dotenv import load_dotenv load_dotenv() KAKAO_CLIENT_ID = os.getenv("KAKAO_CLIENT_ID") KAKAO_REDIRECT_URI = os.getenv("KAKAO_REDIRECT_URI") router = APIRouter(prefix="/api/v1", tags=["Auth"]) @router.post("/register", response_model=RegisterResponse) def register(req: RegisterRequest, db: Session = Depends(get_db)): # ì¤‘ë³µ ê²€ì‚¬ if db.query(User).filter(User.id == req.loginId).first(): raise HTTPException(status_code=400, detail="Login ID already exists") if db.query(User).filter(User.email == req.email).first(): raise HTTPException(status_code=400, detail="Email already registered") # ì‚¬ìš©ì ìƒì„± user = User( id=req.loginId, email=req.email, password=hash_password(req.password) ) db.add(user) db.commit() db.refresh(user) return RegisterResponse( message="User registered successfully", user_id=user.u_id ) @router.post("/login", response_model=LoginResponse) def login(req: LoginRequest, db: Session = Depends(get_db)): user = db.query(User).filter(User.id == req.loginId).first() if not user: raise HTTPException(status_code=404, detail="User not found") if not verify_password(req.password, user.password): raise HTTPException(status_code=401, detail="Invalid password") token = create_access_token(user_id=user.u_id) return LoginResponse( message="Login successful", user_id=user.u_id, access_token=token ) @router.post("/login/google", response_model=LoginResponse) def login_google(req: GoogleLoginRequest, db: Session = Depends(get_db)): try: id_info = id_token.verify_oauth2_token( req.token, grequests.Request(), os.getenv("GOOGLE_CLIENT_ID") ) except Exception: raise HTTPException(status_code=401, detail="Invalid Google token") google_id = id_info.get("sub") email = id_info.get("email") user = db.query(User).filter( User.id == google_id, User.provider == 'google' ).first() if not user: user = User( id=google_id, email=email, password="google_dummy", provider="google" ) db.add(user) db.commit() db.refresh(user) token = create_access_token(user_id=user.u_id) return LoginResponse( message="Google login success", user_id=user.u_id, access_token=token ) @router.post("/login/naver", response_model=LoginResponse) def login_naver(req: NaverLoginRequest, db: Session = Depends(get_db)): # 1) ì•¡ì„¸ìŠ¤ í† í° ìš”ì²­ token_url = ( f"https://nid.naver.com/oauth2.0/token" f"?grant_type=authorization_code" f"&client_id={os.getenv('NAVER_CLIENT_ID')}" f"&client_secret={os.getenv('NAVER_CLIENT_SECRET')}" f"&code={req.code}&state={req.state}" ) token_res = requests.get(token_url) if token_res.status_code != 200: raise HTTPException(status_code=400, detail="Naver token ìš”ì²­ ì‹¤íŒ¨") access_token = token_res.json().get("access_token") headers = {"Authorization": f"Bearer {access_token}"} # 2) í”„ë¡œí•„ ì •ë³´ ìš”ì²­ profile_res = requests.get( "https://openapi.naver.com/v1/nid/me", headers=headers ) profile_data = profile_res.json() if profile_data.get("resultcode") != "00": raise HTTPException(status_code=400, detail="Naver ì‚¬ìš©ì ì •ë³´ ìš”ì²­ ì‹¤íŒ¨") naver_id = profile_data["response"]["id"] email = profile_data["response"].get("email", f"{naver_id}@naver.local") # 3) DB ì¡°íšŒ ë˜ëŠ” ìƒì„± user = db.query(User).filter( User.id == naver_id, User.provider == 'naver' ).first() if not user: user = User( id=naver_id, email=email, password="naver_dummy", provider="naver" ) db.add(user) db.commit() db.refresh(user) token = create_access_token(user_id=user.u_id) return LoginResponse( message="Naver login success", user_id=user.u_id, access_token=token ) # ì¹´ì¹´ì˜¤ ì½œë°± ë¼ìš°í„° @router.post("/auth/kakao/callback", response_model=LoginResponse) def kakao_callback(code: str = Form(...), db: Session = Depends(get_db)): logging.warning(f"ë°›ì€ code: {code}") token_url = "https://kauth.kakao.com/oauth/token" token_data = { "grant_type": "authorization_code", "client_id": KAKAO_CLIENT_ID, "redirect_uri": KAKAO_REDIRECT_URI, "code": code, } token_headers = { "Content-Type": "application/x-www-form-urlencoded" } token_res = requests.post(token_url, data=token_data, headers=token_headers) if token_res.status_code != 200: raise HTTPException(status_code=400, detail="Kakao token ìš”ì²­ ì‹¤íŒ¨") access_token = token_res.json().get("access_token") if not access_token: raise HTTPException(status_code=400, detail="ì•¡ì„¸ìŠ¤ í† í° ì—†ìŒ") profile_res = requests.get( "https://kapi.kakao.com/v2/user/me", headers={"Authorization": f"Bearer {access_token}"} ) if profile_res.status_code != 200: raise HTTPException(status_code=400, detail="Kakao ì‚¬ìš©ì ì •ë³´ ìš”ì²­ ì‹¤íŒ¨") kakao_info = profile_res.json() kakao_id = str(kakao_info.get("id")) kakao_account = kakao_info.get("kakao_account", {}) email = kakao_account.get("email", f"{kakao_id}@kakao.com") user = db.query(User).filter(User.id == kakao_id, User.provider == "kakao").first() if not user: user = User(id=kakao_id, email=email, password="kakao_dummy", provider="kakao") db.add(user) db.commit() db.refresh(user) token = create_access_token(user_id=user.u_id) return LoginResponse( message="Kakao login success", user_id=user.u_id, access_token=token ) # backend/routers/file.py import os import urllib.parse import io import numpy as np # numpy ì„í¬íŠ¸ (ì´ë¯¸ì§€ë¥¼ ë°°ì—´ë¡œ ë³€í™˜í•˜ê¸° ìœ„í•¨) from typing import List, Optional from fastapi import APIRouter, Depends, UploadFile, File, Form, HTTPException, status from fastapi.responses import FileResponse from sqlalchemy.orm import Session from db import get_db from models.file import File as FileModel from models.note import Note as NoteModel # Note ëª¨ë¸ ì„í¬íŠ¸ from utils.jwt_utils import get_current_user from models.user import User # ------------------------------- # 1) PIL(Image) ë° OCR ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„í¬íŠ¸ # ------------------------------- from PIL import Image # PIL.Image ì„í¬íŠ¸ from easyocr import Reader # EasyOCR Reader ì„í¬íŠ¸ # Korean, English ì§€ì›, GPU ì‚¬ìš© reader = Reader(["ko", "en"], gpu=True) # EasyOCR Reader ì´ˆê¸°í™” # ------------------------------- # 2) Summarization ëª¨ë¸ ë¡œë“œ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€í•˜ë˜ ì£¼ì„ ì²˜ë¦¬) # ------------------------------- from transformers import pipeline summarizer = pipeline( "summarization", model="facebook/bart-large-cnn", tokenizer="facebook/bart-large-cnn", device=-1 # CPU ì‚¬ìš©. GPU ì‚¬ìš© ì‹œ 0 ë˜ëŠ” ì ì ˆí•œ ë²ˆí˜¸ë¡œ ë³€ê²½ ) # ì—…ë¡œë“œ ë””ë ‰í† ë¦¬ ì„¤ì • BASE_UPLOAD_DIR = os.path.join( os.path.dirname(os.path.abspath(__file__)), "..", "uploads" ) os.makedirs(BASE_UPLOAD_DIR, exist_ok=True) router = APIRouter(prefix="/api/v1/files", tags=["Files"]) @router.post( "/upload", summary="í´ë”ì— íŒŒì¼ ì—…ë¡œë“œ", status_code=status.HTTP_201_CREATED ) async def upload_file( folder_id: Optional[int] = Form(None), upload_file: UploadFile = File(...), db: Session = Depends(get_db), current_user: User = Depends(get_current_user) ): orig_filename: str = upload_file.filename or "unnamed" content_type: str = upload_file.content_type or "application/octet-stream" # ì‚¬ìš©ìë³„ ë””ë ‰í† ë¦¬ ìƒì„± user_dir = os.path.join(BASE_UPLOAD_DIR, str(current_user.u_id)) os.makedirs(user_dir, exist_ok=True) # ì›ë³¸ íŒŒì¼ëª… ê·¸ëŒ€ë¡œ ì €ì¥ (ë™ëª…ì´ì¸ ë°©ì§€) saved_filename = orig_filename saved_path = os.path.join(user_dir, saved_filename) if os.path.exists(saved_path): name, ext = os.path.splitext(orig_filename) counter = 1 while True: candidate = f"{name}_{counter}{ext}" candidate_path = os.path.join(user_dir, candidate) if not os.path.exists(candidate_path): saved_filename = candidate saved_path = candidate_path break counter += 1 # íŒŒì¼ ì €ì¥ try: with open(saved_path, "wb") as buffer: content = await upload_file.read() buffer.write(content) except Exception as e: raise HTTPException(status_code=500, detail=f"íŒŒì¼ ì €ì¥ ì‹¤íŒ¨: {e}") # DBì— ë©”íƒ€ë°ì´í„° ê¸°ë¡ new_file = FileModel( user_id=current_user.u_id, folder_id=folder_id, original_name=orig_filename, saved_path=saved_path, content_type=content_type ) db.add(new_file) db.commit() db.refresh(new_file) return { "file_id": new_file.id, "original_name": new_file.original_name, "folder_id": new_file.folder_id, "content_type": new_file.content_type, "created_at": new_file.created_at } @router.get( "/list/{folder_id}", response_model=List[dict], summary="íŠ¹ì • í´ë”ì— ì†í•œ íŒŒì¼ ëª©ë¡ ì¡°íšŒ" ) def list_files_in_folder( folder_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user) ): files = ( db.query(FileModel) .filter( FileModel.folder_id == folder_id, FileModel.user_id == current_user.u_id ) .order_by(FileModel.created_at.desc()) .all() ) return [ { "file_id": f.id, "original_name": f.original_name, "content_type": f.content_type, "created_at": f.created_at } for f in files ] @router.get( "/download/{file_id}", summary="íŒŒì¼ ë¯¸ë¦¬ë³´ê¸° (ì¸ì¦ ì—†ì´ ë°”ë¡œ ì—´ë¦¼)" ) def download_file( file_id: int, db: Session = Depends(get_db), ): file_obj = db.query(FileModel).filter(FileModel.id == file_id).first() if not file_obj: raise HTTPException(status_code=404, detail="íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.") file_path = file_obj.saved_path if not os.path.exists(file_path): raise HTTPException(status_code=404, detail="ì„œë²„ì— íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.") filename_star = urllib.parse.quote(file_obj.original_name, safe='') content_disposition = f"inline; filename*=UTF-8''{filename_star}" return FileResponse( path=file_path, media_type=file_obj.content_type, headers={"Content-Disposition": content_disposition} ) @router.post( "/ocr", summary="ì´ë¯¸ì§€ OCR â†’ í…ìŠ¤íŠ¸ ë³€í™˜ í›„ ë…¸íŠ¸ ìƒì„±", response_model=dict ) async def ocr_and_create_note( ocr_file: UploadFile = File(...), folder_id: Optional[int] = Form(None), # ë…¸íŠ¸ë¥¼ ì €ì¥í•  í´ë” ID (ì„ íƒ) db: Session = Depends(get_db), current_user: User = Depends(get_current_user) ): """ â€¢ ocr_file: ì´ë¯¸ì§€ íŒŒì¼(UploadFile) â€¢ 1) EasyOCR ëª¨ë¸ë¡œ í…ìŠ¤íŠ¸ ì¸ì‹ (í•œê¸€Â·ì˜ì–´ ì§€ì›, GPU ì‚¬ìš©) â€¢ 2) ì¸ì‹ëœ í…ìŠ¤íŠ¸ë¥¼ ìƒˆë¡œìš´ Note ëª¨ë¸ë¡œ ì €ì¥ â€¢ ê²°ê³¼: {"note_id": ìƒˆë¡œ ìƒì„±ëœ ë…¸íŠ¸ ID, "text": "ì¸ì‹ëœ í…ìŠ¤íŠ¸"} ë°˜í™˜ """ # ---------- # 1) ì´ë¯¸ì§€ ì²˜ë¦¬ â†’ OCR í…ìŠ¤íŠ¸ ì¶”ì¶œ # ---------- contents = await ocr_file.read() try: image = Image.open(io.BytesIO(contents)).convert("RGB") except Exception as e: raise HTTPException(status_code=400, detail=f"ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹¤íŒ¨: {e}") try: # PIL ì´ë¯¸ì§€ë¥¼ numpy ë°°ì—´ë¡œ ë³€í™˜ image_np = np.array(image) # EasyOCRë¡œ í…ìŠ¤íŠ¸ ì¶”ì¶œ results = reader.readtext(image_np) if not results: raise ValueError("í…ìŠ¤íŠ¸ë¥¼ ì¸ì‹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.") # ì¸ì‹ëœ í…ìŠ¤íŠ¸ë“¤ ê²°í•© ocr_text = " ".join([res[1] for res in results]) except Exception as e: raise HTTPException(status_code=500, detail=f"OCR ìˆ˜í–‰ ì‹¤íŒ¨: {e}") # ---------- # 2) Summarization ë¶€ë¶„ ì£¼ì„ ì²˜ë¦¬ # ---------- # try: # summary_list = summarizer( # ocr_text, # max_length=120, # min_length=30, # do_sample=False # ) # summarized_text = summary_list[0]["summary_text"] # except Exception as e: # summarized_text = "" # print(f"[OCR & Summarization] ìš”ì•½ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}") # ---------- # 3) ìƒˆ ë…¸íŠ¸ ìƒì„± ë° DBì— ì €ì¥ (ì´ë¯¸ì§€ í…ìŠ¤íŠ¸ ê²°ê³¼ ì €ì¥) # ---------- try: new_note = NoteModel( user_id=current_user.u_id, folder_id=folder_id, title="OCR ê²°ê³¼", # ê³ ì • ì œëª©. í•„ìš” ì‹œ ë³€ê²½ ê°€ëŠ¥ content=ocr_text ) db.add(new_note) db.commit() db.refresh(new_note) except Exception as e: raise HTTPException(status_code=500, detail=f"ë…¸íŠ¸ ì €ì¥ ì‹¤íŒ¨: {e}") return { "note_id": new_note.id, "text": ocr_text } # Backend/routers/folder.py from fastapi import APIRouter, Depends, HTTPException, status from sqlalchemy.orm import Session from typing import List, Optional from db import get_db from models.folder import Folder from models.note import Note from schemas.folder import FolderCreate, FolderResponse, FolderUpdate from schemas.note import NoteResponse from utils.jwt_utils import get_current_user router = APIRouter(prefix="/api/v1", tags=["Folders"]) def get_all_descendant_folder_ids(db: Session, parent_id: int, user_id: int) -> List[int]: """ â— í´ë”ë¥¼ ì‚­ì œí•  ë•Œ, í•˜ìœ„ í´ë”(ìì†)ë“¤ê¹Œì§€ ì „ë¶€ ì‚­ì œí•˜ê¸° ìœ„í•´ ì¬ê·€ì ìœ¼ë¡œ descendant IDë¥¼ ìˆ˜ì§‘í•©ë‹ˆë‹¤. """ result: List[int] = [] stack = [parent_id] while stack: current = stack.pop() result.append(current) children = ( db .query(Folder.id) .filter(Folder.parent_id == current, Folder.user_id == user_id) .all() ) stack.extend([child.id for child in children]) return result @router.get( "/folders", response_model=List[FolderResponse], summary="ìœ ì €ì˜ ëª¨ë“  í´ë”(íŠ¸ë¦¬ êµ¬ì¡°) ë° í´ë”ë³„ ë…¸íŠ¸ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜" ) def list_folders( db: Session = Depends(get_db), user = Depends(get_current_user) ): """ 1) í•´ë‹¹ ìœ ì €ì˜ ëª¨ë“  í´ë”ì™€ ë…¸íŠ¸ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤. 2) ë…¸íŠ¸ë“¤ì€ folder_id ê¸°ì¤€ìœ¼ë¡œ ê·¸ë£¹í•‘í•©ë‹ˆë‹¤. 3) ê° í´ë” ê°ì²´ì— children(í•˜ìœ„í´ë”)ì™€ notes(í´ë” ë‚´ ë…¸íŠ¸) ì†ì„±ì„ ë™ì ìœ¼ë¡œ ë¶™ì…ë‹ˆë‹¤. 4) ë¶€ëª¨ê°€ ì—†ëŠ”(root) í´ë”ë§Œ ë½‘ì•„ì„œ íŠ¸ë¦¬ í˜•íƒœ(List[Folder])ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤. """ all_folders = db.query(Folder).filter(Folder.user_id == user.u_id).all() all_notes = db.query(Note).filter(Note.user_id == user.u_id).all() # (2) ë…¸íŠ¸ë“¤ì„ folder_id ê¸°ì¤€ìœ¼ë¡œ ê·¸ë£¹í•‘ folder_note_map: dict[int, List[Note]] = {} for n in all_notes: folder_note_map.setdefault(n.folder_id, []).append(n) # (3) Folder ê°ì²´ì— children, notes ì†ì„± ì¶”ê°€ id_map = {f.id: f for f in all_folders} for f in all_folders: setattr(f, 'children', []) # children: List[Folder] setattr(f, 'notes', folder_note_map.get(f.id, [])) # notes: List[Note] # (4) íŠ¸ë¦¬ í˜•íƒœ êµ¬ì„± roots: List[Folder] = [] for f in all_folders: if f.parent_id is not None and f.parent_id in id_map: id_map[f.parent_id].children.append(f) else: roots.append(f) return roots @router.post( "/folders", response_model=FolderResponse, status_code=status.HTTP_201_CREATED, summary="ìƒˆ í´ë” ìƒì„±" ) def create_folder( req: FolderCreate, db: Session = Depends(get_db), user = Depends(get_current_user) ): """ â€¢ req.name (ë¬¸ìì—´, í•„ìˆ˜) â€¢ req.parent_id (ì •ìˆ˜ or null) - ìµœìƒìœ„ í´ë”ë©´ None """ new_folder = Folder( user_id = user.u_id, name = req.name, parent_id = req.parent_id ) db.add(new_folder) db.commit() db.refresh(new_folder) # children, notes ì†ì„± ì´ˆê¸°í™” setattr(new_folder, 'children', []) setattr(new_folder, 'notes', []) return new_folder @router.patch( "/folders/{folder_id}", response_model=FolderResponse, summary="í´ë” ì´ë¦„ ë³€ê²½ ë°/ë˜ëŠ” ë¶€ëª¨ í´ë” ì´ë™" ) def update_folder( folder_id: int, req: FolderUpdate, db: Session = Depends(get_db), user = Depends(get_current_user) ): """ â— ì´ë¦„(name) ë³€ê²½ì´ ìˆìœ¼ë©´ ë°”ê¿”ì£¼ê³ , â— ë¶€ëª¨í´ë”(parent_id) ë³€ê²½ì´ ìˆìœ¼ë©´ ë°”ê¿”ì¤ë‹ˆë‹¤. (ìì‹ ì„ ìì‹ ì˜ í•˜ìœ„ë¡œ ì§€ì •í•˜ëŠ” ê²½ìš°ë¥¼ ë°©ì§€í•˜ë ¤ë©´ í”„ë¡ íŠ¸ì—ì„œ ë¶€ëª¨ID ê²€ì¦ í˜¹ì€ ë°±ì—”ë“œì—ì„œ ì¶”ê°€ ê²€ì¦ í•„ìš”) """ folder = ( db .query(Folder) .filter(Folder.id == folder_id, Folder.user_id == user.u_id) .first() ) if not folder: raise HTTPException(status_code=404, detail="Folder not found") if req.name is not None: folder.name = req.name if req.parent_id is not None: folder.parent_id = req.parent_id db.commit() db.refresh(folder) # ì‘ë‹µ ì‹œ children, notesëŠ” ë¹ˆ ë°°ì—´ë¡œ ì´ˆê¸°í™” setattr(folder, 'children', []) setattr(folder, 'notes', []) return folder @router.delete( "/folders/{folder_id}", summary="í´ë” ë° ëª¨ë“  í•˜ìœ„ í´ë”Â·ë…¸íŠ¸ ì¼ê´„ ì‚­ì œ" ) def delete_folder( folder_id: int, db: Session = Depends(get_db), user = Depends(get_current_user) ): """ 1) í•´ë‹¹ í´ë”(ë° í•˜ìœ„í´ë”)ì˜ ID ëª©ë¡ì„ ì¬ê·€ì ìœ¼ë¡œ ìˆ˜ì§‘ 2) ê·¸ IDë“¤ì— ì†í•œ ë…¸íŠ¸ë“¤ì„ ëª¨ë‘ ì‚­ì œ 3) ê·¸ IDë“¤ì— ì†í•œ í´ë”ë“¤ì„ ëª¨ë‘ ì‚­ì œ """ folder = ( db .query(Folder) .filter(Folder.id == folder_id, Folder.user_id == user.u_id) .first() ) if not folder: raise HTTPException(status_code=404, detail="Folder not found") all_folder_ids = get_all_descendant_folder_ids(db, folder_id, user.u_id) # (2) í•´ë‹¹ í´ë”ë“¤ ì•ˆì˜ ëª¨ë“  ë…¸íŠ¸ ì‚­ì œ db.query(Note).filter(Note.folder_id.in_(all_folder_ids)).delete(synchronize_session=False) # (3) í•´ë‹¹ í´ë”ë“¤ ì‚­ì œ db.query(Folder).filter(Folder.id.in_(all_folder_ids)).delete(synchronize_session=False) db.commit() return {"message": f"Deleted folder and its {len(all_folder_ids)-1} subfolders."} # src/routers/note.py import os import requests from dotenv import load_dotenv from fastapi import APIRouter, Depends, HTTPException, status from sqlalchemy.orm import Session from typing import List from datetime import datetime from db import get_db from models.note import Note from schemas.note import NoteCreate, NoteUpdate, NoteResponse, FavoriteUpdate from utils.jwt_utils import get_current_user load_dotenv() HF_TOKEN = os.getenv("HF_API_TOKEN") router = APIRouter(prefix="/api/v1", tags=["Notes"]) # ëª¨ë“  ë…¸íŠ¸ ì¡°íšŒ @router.get("/notes", response_model=List[NoteResponse]) def list_notes( db: Session = Depends(get_db), user = Depends(get_current_user) ): return ( db.query(Note) .filter(Note.user_id == user.u_id) .order_by(Note.created_at.desc()) .all() ) # ìµœê·¼ ì ‘ê·¼í•œ ë…¸íŠ¸ ì¡°íšŒ (ìƒìœ„ 10ê°œë¡œ ë³€ê²½) @router.get("/notes/recent", response_model=List[NoteResponse]) def recent_notes( db: Session = Depends(get_db), user = Depends(get_current_user) ): return ( db.query(Note) .filter(Note.user_id == user.u_id, Note.last_accessed.isnot(None)) .order_by(Note.last_accessed.desc()) .limit(10) # â† ê¸°ì¡´ 5 â†’ 10 .all() ) # ë…¸íŠ¸ ìƒì„± @router.post("/notes", response_model=NoteResponse) def create_note( req: NoteCreate, db: Session = Depends(get_db), user = Depends(get_current_user) ): note = Note( user_id=user.u_id, folder_id=req.folder_id, title=req.title, content=req.content ) db.add(note) db.commit() db.refresh(note) return note # ë…¸íŠ¸ ìˆ˜ì • (ì œëª©/ë‚´ìš©/í´ë”) â€“ NoteUpdate ì‚¬ìš© @router.patch("/notes/{note_id}", response_model=NoteResponse) def update_note( note_id: int, req: NoteUpdate, # NoteUpdate ë¡œ ë³€ê²½ db: Session = Depends(get_db), user = Depends(get_current_user) ): note = db.query(Note).filter(Note.id == note_id, Note.user_id == user.u_id).first() if not note: raise HTTPException(status_code=404, detail="Note not found") # Optional í•„ë“œë§Œ ì—…ë°ì´íŠ¸ if req.title is not None: note.title = req.title if req.content is not None: note.content = req.content if req.folder_id is not None: note.folder_id = req.folder_id note.updated_at = datetime.utcnow() db.commit() db.refresh(note) return note # ë…¸íŠ¸ ë‹¨ì¼ ì¡°íšŒ @router.get("/notes/{note_id}", response_model=NoteResponse) def get_note( note_id: int, db: Session = Depends(get_db), user = Depends(get_current_user) ): note = db.query(Note).filter(Note.id == note_id, Note.user_id == user.u_id).first() if not note: raise HTTPException(404, "Note not found") # ì¡°íšŒ ì‹œ ë§ˆì§€ë§‰ ì ‘ê·¼ ì‹œê°„ ê°±ì‹  note.last_accessed = datetime.utcnow() db.commit() db.refresh(note) return note # ë…¸íŠ¸ ì‚­ì œ @router.delete("/notes/{note_id}") def delete_note( note_id: int, db: Session = Depends(get_db), user = Depends(get_current_user) ): note = db.query(Note).filter(Note.id == note_id, Note.user_id == user.u_id).first() if not note: raise HTTPException(status_code=404, detail="Note not found") db.delete(note) db.commit() return {"message": "Note deleted successfully"} # ì¦ê²¨ì°¾ê¸° í† ê¸€ @router.patch("/notes/{note_id}/favorite", response_model=NoteResponse) def toggle_favorite( note_id: int, req: FavoriteUpdate, db: Session = Depends(get_db), user = Depends(get_current_user) ): note = db.query(Note).filter(Note.id == note_id, Note.user_id == user.u_id).first() if not note: raise HTTPException(status_code=404, detail="Note not found") note.is_favorite = req.is_favorite note.updated_at = datetime.utcnow() db.commit() db.refresh(note) return note # ë…¸íŠ¸ ìš”ì•½ (LLM í˜¸ì¶œ) @router.post("/notes/{note_id}/summarize", response_model=NoteResponse) def summarize_note( note_id: int, db: Session = Depends(get_db), user = Depends(get_current_user) ): note = db.query(Note).filter( Note.id == note_id, Note.user_id == user.u_id ).first() if not note: raise HTTPException(404, "Note not found") original = note.content or "" if not original.strip(): raise HTTPException(400, "ë‚´ìš©ì´ ë¹„ì–´ ìˆì–´ ìš”ì•½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.") # ì‹¤ì œ ìš”ì•½ í•¨ìˆ˜ í˜¸ì¶œ from utils.llm import summarize_with_qwen3 # â† ì´ ì‹œì ì— utils/llm.pyê°€ ë¡œë“œë˜ë©° ì˜¤ë¥˜ ë°œìƒ load_dotenv() HF_TOKEN = os.getenv("HF_API_TOKEN") note.updated_at = datetime.utcnow() db.commit() db.refresh(note) return note # Backend/schemas/folder.py from pydantic import BaseModel from typing import Optional, List from schemas.note import NoteResponse class FolderCreate(BaseModel): name: str parent_id: Optional[int] = None class FolderUpdate(BaseModel): name: Optional[str] = None parent_id: Optional[int] = None class FolderResponse(BaseModel): id: int user_id: int name: str parent_id: Optional[int] children: List['FolderResponse'] = [] notes: List[NoteResponse] = [] class Config: from_attributes = True FolderResponse.update_forward_refs() # src/schemas/note.py from pydantic import BaseModel from typing import Optional from datetime import datetime class NoteCreate(BaseModel): title: str content: Optional[str] = None folder_id: Optional[int] = None class NoteUpdate(BaseModel): title: Optional[str] = None content: Optional[str] = None folder_id: Optional[int] = None # í•„ìš”ì— ë”°ë¼ is_favorite ê°™ì€ í•„ë“œë„ ì¶”ê°€ ê°€ëŠ¥ is_favorite: Optional[bool] = None class FavoriteUpdate(BaseModel): is_favorite: bool class NoteResponse(BaseModel): id: int user_id: int folder_id: Optional[int] title: str content: Optional[str] is_favorite: bool last_accessed: Optional[datetime] created_at: datetime updated_at: datetime class Config: from_attributes = True # schemas/user.py from pydantic import BaseModel class RegisterRequest(BaseModel): loginId: str email: str password: str class RegisterResponse(BaseModel): message: str user_id: int # int íƒ€ì…ìœ¼ë¡œ ë³€ê²½ class LoginRequest(BaseModel): loginId: str password: str class LoginResponse(BaseModel): message: str user_id: int # int íƒ€ì…ìœ¼ë¡œ ë³€ê²½ access_token: str class KakaoLoginRequest(BaseModel): code: str class GoogleLoginRequest(BaseModel): token: str class NaverLoginRequest(BaseModel): code: str state: str import smtplib from email.mime.text import MIMEText from email_validator import validate_email, EmailNotValidError from fastapi import HTTPException # ì¸ì¦ ì½”ë“œ ìƒì„± í•¨ìˆ˜ def generate_verification_code(): import random return str(random.randint(100000, 999999)) # ì´ë©”ì¼ ì „ì†¡ í•¨ìˆ˜ def send_email(smtp_user: str, smtp_password: str, email: str, code: str): smtp_server = "smtp.gmail.com" smtp_port = 587 subject = "AI Keeper ì¸ì¦ ë©”ì¼ì…ë‹ˆë‹¤." body = f"ì¸ì¦ì½”ë“œ: {code}" msg = MIMEText(body) msg["Subject"] = subject msg["From"] = smtp_user msg["To"] = email # ì´ë©”ì¼ ìœ íš¨ì„± ê²€ì‚¬ try: valid = validate_email(email) email = valid.email # ì •ì œëœ ì´ë©”ì¼ ì£¼ì†Œ ë°˜í™˜ except EmailNotValidError as e: raise HTTPException(status_code=400, detail="Invalid email address.") try: # SMTP ì„œë²„ ì„¤ì • ë° ì´ë©”ì¼ ì „ì†¡ with smtplib.SMTP(smtp_server, smtp_port) as server: server.starttls() server.login(smtp_user, smtp_password) server.sendmail(smtp_user, email, msg.as_string()) except Exception as e: raise HTTPException(status_code=500, detail="Failed to send email.") # utils/jwt_utils.py import os from datetime import datetime, timedelta, timezone from jose import JWTError, jwt import bcrypt from fastapi import HTTPException, Depends from fastapi.security import OAuth2PasswordBearer from sqlalchemy.orm import Session from models.user import User from db import get_db SECRET_KEY = os.getenv("SECRET_KEY", "your_secret_key") ALGORITHM = "HS256" oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/login") def verify_password(plain_password: str, hashed_password: str) -> bool: return bcrypt.checkpw(plain_password.encode(), hashed_password.encode()) def hash_password(password: str) -> str: return bcrypt.hashpw(password.encode(), bcrypt.gensalt(rounds=12)).decode() def create_access_token(user_id: int, expires_delta: timedelta | None = None) -> str: expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes=15)) payload = {"sub": str(user_id), "exp": expire} return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM) async def get_current_user( token: str = Depends(oauth2_scheme), db: Session = Depends(get_db) ): credentials_exception = HTTPException( status_code=401, detail="Could not validate credentials", headers={"WWW-Authenticate": "Bearer"}, ) try: payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) user_id: str = payload.get("sub") if not user_id: raise credentials_exception except JWTError: raise credentials_exception user = db.query(User).filter(User.u_id == int(user_id)).first() if not user: raise credentials_exception return user # ~/noteflow/Backend/utils/llm.py import torch from transformers import AutoConfig, AutoTokenizer, AutoModelForCausalLM _MODEL_NAME = "Qwen/Qwen3-8B" # 1) Config ë¶ˆëŸ¬ì™€ì„œ parallel_style ì§€ì • config = AutoConfig.from_pretrained( _MODEL_NAME, trust_remote_code=True ) # ë³€ê²½: ë°˜ë“œì‹œ "auto"ë¡œ ì§€ì •. NoneType ì˜¤ë¥˜ ë°©ì§€ config.parallel_style = "auto" # 2) í† í¬ë‚˜ì´ì € ë¡œë“œ _tokenizer = AutoTokenizer.from_pretrained( _MODEL_NAME, trust_remote_code=True ) # 3) ëª¨ë¸ ë¡œë“œ ì‹œ config ì¸ì ì¶”ê°€ _model = AutoModelForCausalLM.from_pretrained( _MODEL_NAME, config=config, # custom config ì „ë‹¬ torch_dtype="auto", device_map="auto", trust_remote_code=True ) _model.eval() def summarize_with_qwen3( text: str, max_new_tokens: int = 256, temperature: float = 0.6 ) -> str: """ - í•œêµ­ì–´ ë¬¸ì„œë¥¼ ê°„ê²°í•˜ê³  í•µì‹¬ì ìœ¼ë¡œ ìš”ì•½ - ë°˜í™˜ê°’: ìš”ì•½ëœ í•œêµ­ì–´ ë¬¸ìì—´ """ messages = [ { "role": "system", "content": ( "ë‹¹ì‹ ì€ í•œêµ­ì–´ ë¬¸ì„œë¥¼ ê°„ê²°í•˜ê³  í•µì‹¬ì ìœ¼ë¡œ ìš”ì•½í•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤. " "ìš”ì•½ ì™¸ì—ëŠ” ì ˆëŒ€ ë‹¤ë¥¸ ë§ì„ í•˜ì§€ ë§ˆì„¸ìš”." ) }, { "role": "user", "content": text } ] # apply_chat_template: enable_thinking=False ì „ë‹¬ prompt = _tokenizer.apply_chat_template( messages, tokenize=False, add_generation_prompt=True, enable_thinking=False ) inputs = _tokenizer(prompt, return_tensors="pt").to(_model.device) outputs = _model.generate( **inputs, max_new_tokens=max_new_tokens, temperature=temperature, top_p=0.95, top_k=20, do_sample=False, # ì•ˆì •ì ì¸ ìš”ì•½ì„ ìœ„í•´ ìƒ˜í”Œë§ ë„ê¸° eos_token_id=_tokenizer.eos_token_id ) # ìƒì„±ëœ í† í° ì¤‘ ì…ë ¥ ì´í›„ ë¶€ë¶„ë§Œ ë””ì½”ë”© gen_tokens = outputs[0].tolist()[len(inputs.input_ids[0]):] decoded = _tokenizer.decode(gen_tokens, skip_special_tokens=True) return decoded.strip() import random import string import bcrypt def generate_temp_password(length=10): """ ëœë¤í•œ ì„ì‹œ ë¹„ë°€ë²ˆí˜¸ ìƒì„± (ì˜ë¬¸ + ìˆ«ì ì¡°í•©) """ characters = string.ascii_letters + string.digits return ''.join(random.choice(characters) for _ in range(length)) def hash_password(password: str) -> str: """ ì£¼ì–´ì§„ ë¹„ë°€ë²ˆí˜¸ë¥¼ bcrypt í•´ì‹œë¡œ ë³€í™˜ """ return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(rounds=12)).decode('utf-8') def verify_password(input_password: str, hashed_password: str) -> bool: """ ì…ë ¥ëœ ë¹„ë°€ë²ˆí˜¸ê°€ í•´ì‹œëœ ë¹„ë°€ë²ˆí˜¸ì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸ """ return bcrypt.checkpw(input_password.encode('utf-8'), hashed_password.encode('utf-8')) from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker DATABASE_URL = "mysql+mysqlconnector://noteflow:NoteFlow123!@localhost/noteflow" engine = create_engine(DATABASE_URL) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) # ë°ì´í„°ë² ì´ìŠ¤ ì˜ì¡´ì„± def get_db(): db = SessionLocal() try: yield db finally: db.close() # src/main.py import os from dotenv import load_dotenv from fastapi import FastAPI from fastapi.middleware.cors import CORSMiddleware from routers.auth import router as auth_router from routers.note import router as note_router from routers.folder import router as folder_router from fastapi.staticfiles import StaticFiles from routers.file import router as file_router import logging import uvicorn # 1) í™˜ê²½ë³€ìˆ˜ ë¡œë“œ load_dotenv() # 2) ë¡œê¹… ì„¤ì • logging.basicConfig(level=logging.INFO) logger = logging.getLogger(__name__) # 3) FastAPI ì•± ìƒì„± app = FastAPI() # 4) CORS ì„¤ì • origins = [ "http://localhost:5174", ] app.add_middleware( CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"], ) # 5) ë¼ìš°í„° ë“±ë¡ app.include_router(auth_router) app.include_router(note_router) app.include_router(folder_router) app.include_router(file_router) # 6) ë£¨íŠ¸ ì—”ë“œí¬ì¸íŠ¸ @app.get("/") def read_root(): return {"message": "mini"} # 7) ì‹¤í–‰ ì„¤ì • if __name__ == "__main__": uvicorn.run( "main:app", host="0.0.0.0", port=8080, reload=True, env_file=".env" )

###### ChatGPTì˜ ë§:

ë°±ì—”ë“œ ì½”ë“œì™€ ë””ë ‰í„°ë¦¬ êµ¬ì¡° í™•ì¸í–ˆìŠµë‹ˆë‹¤.  
ë‹¤ìŒìœ¼ë¡œ í”„ë¡ íŠ¸ì—”ë“œ ìª½ ì½”ë“œì™€ íŒŒì¼ êµ¬ì¡°ë¥¼ ê³µìœ í•´ ì£¼ì‹œë©´, ì´ì–´ì„œ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

##### ë‚˜ì˜ ë§:

// src/components/BottomBar.jsx import React from 'react' import '../css/Bottombar.css' export default function BottomBar({ statusText, onRecordClick, onSummarizeClick, onUploadClick, onOcrClick // ì¶”ê°€ëœ prop }) { return ( <footer className="bottom-bar"> <div className="bottom-status"> {statusText && <span>ğŸ”µ {statusText}</span>} </div> <div className="bottom-actions"> <button onClick={onRecordClick}>ë…¹ìŒ</button> <button onClick={onSummarizeClick}>ìš”ì•½</button> <button onClick={onUploadClick}>ì—…ë¡œë“œ</button> <button onClick={onOcrClick}>í…ìŠ¤íŠ¸ ë³€í™˜</button> {/* ìƒˆ ë²„íŠ¼ */} </div> </footer> ) } // src/components/Layout.jsx import React, { useState, useRef, useEffect } from 'react' import { Outlet, useNavigate, useParams } from 'react-router-dom' import Sidebar from './Sidebar' import TopBar from './Topbar' import BottomBar from './Bottombar' import '../css/Layout.css' import '../css/Modal.css' // ëª¨ë‹¬ ì „ìš© ìŠ¤íƒ€ì¼ (ì•„ë˜ì— ì„¤ëª…) export default function Layout() { const navigate = useNavigate() const { folderId: folderIdParam } = useParams() const parsedFolderId = folderIdParam ? parseInt(folderIdParam, 10) : null // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 1) ê²€ìƒ‰, í•„í„°, í˜„ì¬ ë…¸íŠ¸, í˜„ì¬ í´ë” ìƒíƒœ // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ const [search, setSearch] = useState('') const [filter, setFilter] = useState('all') const [currentNote, setCurrentNote] = useState(null) const [selectedFolderId, setSelectedFolderId] = useState(parsedFolderId) useEffect(() => { setSelectedFolderId(parsedFolderId) }, [parsedFolderId]) // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 2) ë…¹ìŒ / ìš”ì•½ / OCR ìƒíƒœ í…ìŠ¤íŠ¸ // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ const [statusText, setStatusText] = useState('') const handleRecord = () => setStatusText('ğŸ”´ ë…¹ìŒì´ ì§„í–‰ì¤‘ì…ë‹ˆë‹¤...') const handleSummarize = async () => { if (!currentNote) return setStatusText('â³ ìš”ì•½ì„ ìˆ˜í–‰ ì¤‘ì…ë‹ˆë‹¤...') const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') try { const res = await fetch( `${API}/api/v1/notes/${currentNote.id}/summarize`, { method: 'POST', headers: { Authorization: `Bearer ${token}` } } ) if (!res.ok) { alert('ìš”ì•½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤') setStatusText('') return } const updated = await res.json() setCurrentNote(updated) setStatusText('âœ… ìš”ì•½ ì™„ë£Œ') } catch (err) { console.error('[Layout] ìš”ì•½ ì¤‘ ì˜ˆì™¸:', err) alert('ìš”ì•½ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.') setStatusText('') } } const toggleFavorite = async () => { if (!currentNote) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') try { const res = await fetch( `${API}/api/v1/notes/${currentNote.id}/favorite`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ is_favorite: !currentNote.is_favorite }) } ) if (res.ok) { const updated = await res.json() setCurrentNote(updated) } else { alert('ì¦ê²¨ì°¾ê¸° ë³€ê²½ ì‹¤íŒ¨') } } catch (err) { console.error('[Layout] ì¦ê²¨ì°¾ê¸° ì²˜ë¦¬ ì¤‘ ì˜ˆì™¸:', err) alert('ì¦ê²¨ì°¾ê¸° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.') } } const handleNewNote = () => navigate('/notes/new') // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 3) íŒŒì¼ ì—…ë¡œë“œ ì²˜ë¦¬ // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ const fileInputRef = useRef() const ocrInputRef = useRef() // OCR ì „ìš© íŒŒì¼ input ref const [uploadTargetFolderId, setUploadTargetFolderId] = useState(null) const handleUploadClick = () => { if (selectedFolderId == null) { alert('ë¨¼ì € ì‚¬ì´ë“œë°”ì—ì„œ ì—…ë¡œë“œí•  í´ë”ë¥¼ ì„ íƒí•˜ì„¸ìš”.') return } setUploadTargetFolderId(selectedFolderId) if (fileInputRef.current) fileInputRef.current.click() } const [fileUploadTimestamp, setFileUploadTimestamp] = useState(0) const handleFilesSelected = async (e) => { const files = e.target.files if (!files || files.length === 0) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') const folderIdToUpload = uploadTargetFolderId if (!folderIdToUpload) { alert('ìœ íš¨í•œ í´ë” IDê°€ ì—†ìŠµë‹ˆë‹¤. ì—…ë¡œë“œë¥¼ ì·¨ì†Œí•©ë‹ˆë‹¤.') e.target.value = null return } for (let i = 0; i < files.length; i++) { const file = files[i] const formData = new FormData() formData.append('upload_file', file) formData.append('folder_id', String(folderIdToUpload)) console.log(`[Layout] íŒŒì¼ ì—…ë¡œë“œ ìš”ì²­ â†’ "${file.name}" â†’ í´ë” ${folderIdToUpload}`) try { const res = await fetch(`${API}/api/v1/files/upload`, { method: 'POST', headers: { Authorization: `Bearer ${token}` }, body: formData }) if (!res.ok) { console.error( `[Layout] íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨: "${file.name}"`, res.status, await res.text() ) } else { console.log(`[Layout] íŒŒì¼ ì—…ë¡œë“œ ì„±ê³µ: "${file.name}"`) } } catch (err) { console.error(`[Layout] íŒŒì¼ ì—…ë¡œë“œ ì¤‘ ì˜ˆì™¸: "${file.name}"`, err) } } setFileUploadTimestamp(Date.now()) setUploadTargetFolderId(null) e.target.value = null } // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 4) OCR ì „ìš© íŒŒì¼ ì„ íƒ ì²˜ë¦¬ (OCR â†’ ìš”ì•½ â†’ ë…¸íŠ¸ ì €ì¥ â†’ ëª¨ë‹¬ ë„ìš°ê¸°) // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // (1) ëª¨ë‹¬ í‘œì‹œë¥¼ ìœ„í•œ ìƒíƒœ const [showModal, setShowModal] = useState(false) const [modalTitle, setModalTitle] = useState('') const [modalBody, setModalBody] = useState('') const handleOcrClick = () => { if (selectedFolderId == null) { alert('ë¨¼ì € ì‚¬ì´ë“œë°”ì—ì„œ OCRì„ ìˆ˜í–‰í•  í´ë”ë¥¼ ì„ íƒí•˜ì„¸ìš”.') return } if (ocrInputRef.current) ocrInputRef.current.click() } const handleOcrSelected = async (e) => { const files = e.target.files if (!files || files.length === 0) return const file = files[0] // ì²« ë²ˆì§¸ íŒŒì¼ë§Œ ì²˜ë¦¬ const formData = new FormData() formData.append('ocr_file', file) const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') // OCR â†’ ìš”ì•½ ì§„í–‰ ìƒíƒœ í‘œì‹œ setStatusText('â³ OCR ë° ìš”ì•½ì„ ìˆ˜í–‰ ì¤‘ì…ë‹ˆë‹¤...') try { const res = await fetch(`${API}/api/v1/files/ocr`, { method: 'POST', headers: { Authorization: `Bearer ${token}` }, body: formData }) if (!res.ok) { alert('ì´ë¯¸ì§€ í…ìŠ¤íŠ¸ ë³€í™˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.') setStatusText('') return } // ì„œë²„ë¡œë¶€í„° { text, summary } í˜•íƒœì˜ JSON ì‘ë‹µì„ ë°›ìŒ const { text, summary } = await res.json() // (2) ìš”ì•½ ê²°ê³¼ë¥¼ ìƒˆë¡œìš´ ë…¸íŠ¸ë¡œ ì €ì¥ let newNoteData = null if (summary && summary.trim().length > 0) { const notePayload = { title: `[OCR ìš”ì•½] ${file.name}`, content: summary, folder_id: selectedFolderId } const noteRes = await fetch(`${API}/api/v1/notes`, { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify(notePayload) }) if (noteRes.ok) { newNoteData = await noteRes.json() } else { console.error( '[Layout] ìš”ì•½ ë…¸íŠ¸ ìƒì„± ì‹¤íŒ¨:', noteRes.status, await noteRes.text() ) } } // (3) ëª¨ë‹¬ì— ë Œë”ë§í•  ë‚´ìš© êµ¬ì„± let bodyHtml = `<h3>OCR ê²°ê³¼</h3><pre class="modal-pre">${text}</pre>` if (summary && summary.trim().length > 0) { bodyHtml += `<h3>ìš”ì•½ ê²°ê³¼</h3><pre class="modal-pre">${summary}</pre>` if (newNoteData) { bodyHtml += `<p>âœ… ìš”ì•½ì„ ìƒˆ ë…¸íŠ¸ë¡œ ì €ì¥í–ˆìŠµë‹ˆë‹¤: â€œ${newNoteData.title}â€</p>` } else { bodyHtml += `<p style="color: #d00;">âš ï¸ ìš”ì•½ ë…¸íŠ¸ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.</p>` } } else { bodyHtml += `<p>âš ï¸ ìš”ì•½ëœ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.</p>` } // (4) ëª¨ë‹¬ í‘œì‹œ setModalTitle('OCR & ìš”ì•½ ê²°ê³¼') setModalBody(bodyHtml) setShowModal(true) setStatusText('âœ… OCR ë° ìš”ì•½ ì™„ë£Œ') } catch (err) { console.error('[Layout] OCR ì¤‘ ì˜ˆì™¸:', err) alert('OCR ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.') setStatusText('') } finally { e.target.value = null } } // ëª¨ë‹¬ ë‹«ê¸° í•¨ìˆ˜ const closeModal = () => { setShowModal(false) setModalTitle('') setModalBody('') } return ( <div className="layout-container"> <Sidebar onFilterChange={setFilter} onSelectFolder={setSelectedFolderId} onNoteSelect={setCurrentNote} /> <div className="layout-body"> <TopBar onNewNote={handleNewNote} searchValue={search} onSearchChange={setSearch} onFavoritesClick={() => setFilter('favorites')} onSettingsClick={() => navigate('/settings')} currentNote={currentNote} onToggleFavorite={toggleFavorite} /> <div className="layout-main"> <Outlet context={{ setCurrentNote, toggleFavorite, filter, selectedFolderId, fileUploadTimestamp, }} /> </div> <BottomBar statusText={statusText} onRecordClick={handleRecord} onSummarizeClick={handleSummarize} onUploadClick={handleUploadClick} onOcrClick={handleOcrClick} // BottomBarì— OCR í´ë¦­ í•¸ë“¤ëŸ¬ ì „ë‹¬ /> </div> {/* ìˆ¨ê²¨ì§„ íŒŒì¼ input (í´ë” ì—…ë¡œë“œìš©) */} <input type="file" ref={fileInputRef} style={{ display: 'none' }} multiple onChange={handleFilesSelected} /> {/* ìˆ¨ê²¨ì§„ íŒŒì¼ input (OCRìš©, single íŒŒì¼ ì²˜ë¦¬) */} <input type="file" ref={ocrInputRef} style={{ display: 'none' }} accept="image/*" onChange={handleOcrSelected} /> {/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ëª¨ë‹¬ ì»´í¬ë„ŒíŠ¸ (showModal=trueì¼ ë•Œ í™”ë©´ ì¤‘ì•™ì— ì˜¤ë²„ë ˆì´) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */} {showModal && ( <div className="modal-overlay" onClick={closeModal}> <div className="modal-dialog" onClick={(e) => e.stopPropagation()}> <div className="modal-header"> <h2>{modalTitle}</h2> <button className="modal-close-btn" onClick={closeModal}>Ã—</button> </div> <div className="modal-content" dangerouslySetInnerHTML={{ __html: modalBody }} /> <div className="modal-footer"> <button className="modal-ok-btn" onClick={closeModal}> í™•ì¸ </button> </div> </div> </div> )} </div> ) } // src/components/Sidebar.jsx import React, { useState, useEffect, useCallback, useRef } from 'react' import { useNavigate } from 'react-router-dom' import '../css/Sidebar.css' export default function Sidebar({ onFilterChange, onSelectFolder, onNoteSelect }) { // 1) ë¡œì»¬ ìƒíƒœ const [flatFolders, setFlatFolders] = useState([]) // ì„œë²„ì—ì„œ ë°›ì•„ì˜¨ í´ë” ë¦¬ìŠ¤íŠ¸ (í‰íƒ„í™”ëœ ë°°ì—´) const [treeFolders, setTreeFolders] = useState([]) // íŠ¸ë¦¬ êµ¬ì¡°ë¡œ ë³€í™˜ëœ í´ë”ë“¤ const [openMap, setOpenMap] = useState({}) // í´ë” ì—´ë¦¼/ë‹«í˜ ìƒíƒœ const [folderNoteMap, setFolderNoteMap] = useState({}) // í´ë”ë³„ ë…¸íŠ¸ ë§¤í•‘ const [folderContextMenu, setFolderContextMenu] = useState({ visible: false, x: 0, y: 0, folderId: null }) const [noteContextMenu, setNoteContextMenu] = useState({ visible: false, x: 0, y: 0, noteId: null, folderId: null }) const [activeFilter, setActiveFilter] = useState('all') // 'all' | 'recent' | 'favorites' const navigate = useNavigate() const contextMenuRef = useRef(null) // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 1) í´ë” ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° (GET /api/v1/folders) // - ë°±ì—”ë“œê°€ íŠ¸ë¦¬ í˜•íƒœë¡œ ë¦¬í„´í•˜ë¯€ë¡œ, ì´ë¥¼ í‰íƒ„í™”í•œ ë’¤ flatFoldersì— ì €ì¥ // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ const loadFolders = useCallback(async () => { try { const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') const res = await fetch(`${API}/api/v1/folders`, { headers: { Authorization: `Bearer ${token}` } }) if (!res.ok) { console.error('[loadFolders] ì‹¤íŒ¨ â†’', res.status, await res.text()) return } const data = await res.json() // íŠ¸ë¦¬ í˜•íƒœì˜ JSONì„ ì¬ê·€ íƒìƒ‰í•˜ì—¬ í‰íƒ„í™” const flattenList = [] const traverse = (node) => { // nodeì—ëŠ” id, user_id, name, parent_id, children, notes ì†ì„±ì´ ì¡´ì¬í•¨ flattenList.push({ id: node.id, user_id: node.user_id, name: node.name, parent_id: node.parent_id }) if (node.children && node.children.length > 0) { node.children.forEach((child) => traverse(child)) } } data.forEach((root) => traverse(root)) setFlatFolders(flattenList) } catch (err) { console.error('[loadFolders] ì˜ˆì™¸ â†’', err) } }, []) // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 2) ë…¸íŠ¸ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° (GET /api/v1/notes) â†’ í´ë”ë³„ ë§¤í•‘ // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ const loadNotes = useCallback(async () => { try { const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') const res = await fetch(`${API}/api/v1/notes`, { headers: { Authorization: `Bearer ${token}` } }) if (!res.ok) { console.error('[loadNotes] ì‹¤íŒ¨ â†’', res.status, await res.text()) return } const notes = await res.json() const map = {} notes.forEach((n) => { const key = n.folder_id ?? null if (!map[key]) map[key] = [] map[key].push(n) }) setFolderNoteMap(map) } catch (err) { console.error('[loadNotes] ì˜ˆì™¸ â†’', err) } }, []) // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 3) ë§ˆìš´íŠ¸ ì‹œ í´ë” & ë…¸íŠ¸ ë™ì‹œì— ë¡œë“œ // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ useEffect(() => { loadFolders() loadNotes() }, [loadFolders, loadNotes]) // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 4) flatFolders + folderNoteMap â†’ íŠ¸ë¦¬ êµ¬ì¡°(treeFolders)ë¡œ ë³€í™˜ // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ useEffect(() => { // flatFoldersë¥¼ í‚¤(id) ê¸°ì¤€ìœ¼ë¡œ ì„ì‹œ ë§µí•‘ const tempMap = {} flatFolders.forEach((f) => { tempMap[f.id] = { ...f, children: [], notes: folderNoteMap[f.id] || [] } }) // ë£¨íŠ¸ ë…¸ë“œ ë°°ì—´ ìƒì„± const roots = [] flatFolders.forEach((f) => { if (f.parent_id == null) { roots.push(tempMap[f.id]) } else if (tempMap[f.parent_id]) { tempMap[f.parent_id].children.push(tempMap[f.id]) } }) setTreeFolders(roots) }, [flatFolders, folderNoteMap]) // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 5) ë“œë˜ê·¸ ì•¤ ë“œë¡­: íŒŒì¼ / ë…¸íŠ¸ / í´ë” ë“œë¡­ ì´ë²¤íŠ¸ ì²˜ë¦¬ // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ const handleDrop = async (e, targetFolderId) => { e.preventDefault() const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') const dataType = e.dataTransfer.getData('type') const droppedNoteId = e.dataTransfer.getData('noteId') const droppedFolderId = e.dataTransfer.getData('folderId') // 5-1) íŒŒì¼ ë“œë¡­ â†’ POST /api/v1/files/upload const droppedFiles = e.dataTransfer.files if (droppedFiles && droppedFiles.length > 0) { for (let i = 0; i < droppedFiles.length; i++) { const file = droppedFiles[i] const formData = new FormData() formData.append('upload_file', file) formData.append('folder_id', targetFolderId) console.log(`[handleDrop] íŒŒì¼ ì—…ë¡œë“œ ìš”ì²­ â†’ "${file.name}" â†’ í´ë” ${targetFolderId}`) try { const res = await fetch(`${API}/api/v1/files/upload`, { method: 'POST', headers: { Authorization: `Bearer ${token}` }, body: formData }) if (!res.ok) { console.error(`[handleDrop] íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨: "${file.name}"`, res.status, await res.text()) } else { console.log(`[handleDrop] íŒŒì¼ ì—…ë¡œë“œ ì„±ê³µ: "${file.name}"`) } } catch (err) { console.error(`[handleDrop] íŒŒì¼ ì—…ë¡œë“œ ì¤‘ ì˜ˆì™¸: "${file.name}"`, err) } } await loadNotes() onFilterChange('all') return } // 5-2) ë…¸íŠ¸ ë“œë¡­ â†’ PATCH /api/v1/notes/{noteId} if (dataType === 'note' && droppedNoteId) { console.log(`[handleDrop] ë…¸íŠ¸ ì´ë™ ìš”ì²­ â†’ noteId=${droppedNoteId}, targetFolderId=${targetFolderId}`) try { const res = await fetch(`${API}/api/v1/notes/${droppedNoteId}`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ folder_id: targetFolderId }) }) if (!res.ok) { console.error('[handleDrop] ë…¸íŠ¸ ì´ë™ ì‹¤íŒ¨:', res.status, await res.text()) } else { console.log('[handleDrop] ë…¸íŠ¸ ì´ë™ ì„±ê³µ:', droppedNoteId, 'â†’', targetFolderId) } await loadNotes() onFilterChange('all') } catch (err) { console.error('[handleDrop] ë…¸íŠ¸ ì´ë™ ì¤‘ ì˜ˆì™¸:', err) } return } // 5-3) í´ë” ë“œë¡­ â†’ PATCH /api/v1/folders/{folderId} if (dataType === 'folder' && droppedFolderId) { const dfId = parseInt(droppedFolderId, 10) const tfId = parseInt(targetFolderId, 10) console.log(`[handleDrop] í´ë” ì´ë™ ìš”ì²­ â†’ folderId=${dfId}, targetFolderId=${tfId}`) if (dfId === tfId) { console.warn('[handleDrop] ìê¸° ìì‹  ìœ„ë¡œ ë“œë¡­ ì‹œë„ â†’ ë¬´ì‹œ') return } if (isDescendant(dfId, tfId)) { console.warn('[handleDrop] ìì‹ ìœ„ë¡œ ë“œë¡­ ì‹œë„ â†’ ë¬´ì‹œ') return } try { const res = await fetch(`${API}/api/v1/folders/${dfId}`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ parent_id: tfId }) }) if (!res.ok) { console.error('[handleDrop] í´ë” ì´ë™ ì‹¤íŒ¨:', res.status, await res.text()) } else { console.log('[handleDrop] í´ë” ì´ë™ ì„±ê³µ:', dfId, 'â†’', tfId) } // í´ë” íŠ¸ë¦¬ ë‹¤ì‹œ ë¡œë“œ await loadFolders() } catch (err) { console.error('[handleDrop] í´ë” ì´ë™ ì¤‘ ì˜ˆì™¸:', err) } return } } const isDescendant = (droppedId, targetId) => { const stack = [droppedId] const visited = new Set() const childMap = {} flatFolders.forEach((f) => { if (!childMap[f.parent_id]) childMap[f.parent_id] = [] childMap[f.parent_id].push(f.id) }) while (stack.length > 0) { const curr = stack.pop() if (visited.has(curr)) continue visited.add(curr) const children = childMap[curr] || [] if (children.includes(targetId)) return true stack.push(...children) } return false } // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 6) í´ë” / ë…¸íŠ¸ CRUD í•¸ë“¤ëŸ¬ // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 6-1) ìƒˆ í´ë” ìƒì„± const handleNewFolder = async (parentId) => { const name = prompt('ìƒˆ í´ë” ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”') if (!name) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') console.log('[handleNewFolder] í˜¸ì¶œë¨ â†’ parentId=', parentId, ', name=', name) try { const res = await fetch(`${API}/api/v1/folders`, { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ name: name, parent_id: parentId }) }) console.log('[handleNewFolder] ìš”ì²­ ë°”ë”” â†’', JSON.stringify({ name, parent_id: parentId })) if (!res.ok) { console.error('[handleNewFolder] í´ë” ìƒì„± ì‹¤íŒ¨:', res.status, await res.text()) alert('í´ë” ìƒì„± ì‹¤íŒ¨. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.') return } const created = await res.json() console.log('[handleNewFolder] í´ë” ìƒì„± ì„±ê³µ:', created) // â‘  ì„œë²„ì—ì„œ ìµœì‹  í´ë” ëª©ë¡ì„ ë‹¤ì‹œ ê°€ì ¸ì˜´ await loadFolders() // â‘¡ í•„í„° ì´ˆê¸°í™”(â€˜ë‚´ í´ë”â€™ íƒ­) setActiveFilter('all') onFilterChange('all') // â‘¢ í´ë” ìƒì„± ìœ„ì¹˜(ë¶€ëª¨ í´ë”)ë¥¼ ìë™ í™•ì¥ if (parentId !== null) { setOpenMap((prev) => ({ ...prev, [parentId]: true })) } } catch (err) { console.error('[handleNewFolder] ì˜ˆì™¸ ë°œìƒ:', err) alert('í´ë” ìƒì„± ì¤‘ ì˜ˆì™¸ ë°œìƒ. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.') } } // 6-2) ìƒˆ ë…¸íŠ¸ ìƒì„± const handleNewNote = async (folderId) => { const title = prompt('ë…¸íŠ¸ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”') if (!title) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') console.log('[handleNewNote] í˜¸ì¶œë¨ â†’ folderId=', folderId, ', title=', title) try { const res = await fetch(`${API}/api/v1/notes`, { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ title: title, content: '', folder_id: folderId }) }) console.log('[handleNewNote] ìš”ì²­ ë°”ë”” â†’', JSON.stringify({ title, content: '', folder_id: folderId })) if (!res.ok) { console.error('[handleNewNote] ë…¸íŠ¸ ìƒì„± ì‹¤íŒ¨:', res.status, await res.text()) alert('ë…¸íŠ¸ ìƒì„± ì‹¤íŒ¨. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.') return } const created = await res.json() console.log('[handleNewNote] ë…¸íŠ¸ ìƒì„± ì„±ê³µ:', created) // ë…¸íŠ¸ ëª©ë¡ ë‹¤ì‹œ ë¡œë“œ await loadNotes() } catch (err) { console.error('[handleNewNote] ì˜ˆì™¸ ë°œìƒ:', err) alert('ë…¸íŠ¸ ìƒì„± ì¤‘ ì˜ˆì™¸ ë°œìƒ. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.') } } // 6-3) ë…¸íŠ¸ ì´ë¦„ ë³€ê²½ const handleRenameNote = async (noteId, folderId) => { const newTitle = prompt('ìƒˆ ë…¸íŠ¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”') if (!newTitle) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') console.log('[handleRenameNote] í˜¸ì¶œë¨ â†’ noteId=', noteId, 'folderId=', folderId, ', newTitle=', newTitle) try { const res = await fetch(`${API}/api/v1/notes/${noteId}`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ title: newTitle, folder_id: folderId }) }) console.log('[handleRenameNote] ìš”ì²­ ë°”ë”” â†’', JSON.stringify({ title: newTitle, folder_id: folderId })) if (!res.ok) { console.error('[handleRenameNote] ë…¸íŠ¸ ì´ë¦„ ë³€ê²½ ì‹¤íŒ¨:', res.status, await res.text()) return } const updated = await res.json() console.log('[handleRenameNote] ë…¸íŠ¸ ì´ë¦„ ë³€ê²½ ì„±ê³µ:', updated) // ë…¸íŠ¸ ëª©ë¡ ë‹¤ì‹œ ë¡œë“œ await loadNotes() } catch (err) { console.error('[handleRenameNote] ì˜ˆì™¸ ë°œìƒ:', err) } } // 6-4) í´ë” ì´ë¦„ ë³€ê²½ const handleRenameFolder = async (folderId) => { const name = prompt('ìƒˆ í´ë” ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”') if (!name) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') console.log('[handleRenameFolder] í˜¸ì¶œë¨ â†’ folderId=', folderId, ', newName=', name) try { const res = await fetch(`${API}/api/v1/folders/${folderId}`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ name: name }) }) console.log('[handleRenameFolder] ìš”ì²­ ë°”ë”” â†’', JSON.stringify({ name })) if (!res.ok) { console.error('[handleRenameFolder] í´ë” ì´ë¦„ ë³€ê²½ ì‹¤íŒ¨:', res.status, await res.text()) return } const updated = await res.json() console.log('[handleRenameFolder] í´ë” ì´ë¦„ ë³€ê²½ ì„±ê³µ:', updated) // í´ë” ëª©ë¡ ë‹¤ì‹œ ë¡œë“œ await loadFolders() } catch (err) { console.error('[handleRenameFolder] ì˜ˆì™¸ ë°œìƒ:', err) } } // 6-5) ë…¸íŠ¸ ì‚­ì œ const handleDeleteNote = async (noteId) => { if (!confirm('ì´ ë…¸íŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') console.log('[handleDeleteNote] í˜¸ì¶œë¨ â†’ noteId=', noteId) try { const res = await fetch(`${API}/api/v1/notes/${noteId}`, { method: 'DELETE', headers: { Authorization: `Bearer ${token}` } }) console.log('[handleDeleteNote] ìš”ì²­ ë³´ëƒ„ â†’', `DELETE ${API}/api/v1/notes/${noteId}`) if (!res.ok) { console.error('[handleDeleteNote] ë…¸íŠ¸ ì‚­ì œ ì‹¤íŒ¨:', res.status, await res.text()) return } console.log('[handleDeleteNote] ë…¸íŠ¸ ì‚­ì œ ì„±ê³µ:', noteId) // ë…¸íŠ¸ ëª©ë¡ ë‹¤ì‹œ ë¡œë“œ await loadNotes() } catch (err) { console.error('[handleDeleteNote] ì˜ˆì™¸ ë°œìƒ:', err) } } // 6-6) í´ë” ì‚­ì œ const handleDeleteFolder = async (folderId) => { if (!confirm('ì •ë§ í´ë”ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return const API = import.meta.env.VITE_API_BASE_URL const token = localStorage.getItem('access_token') console.log('[handleDeleteFolder] í˜¸ì¶œë¨ â†’ folderId=', folderId) try { const res = await fetch(`${API}/api/v1/folders/${folderId}`, { method: 'DELETE', headers: { Authorization: `Bearer ${token}` } }) console.log('[handleDeleteFolder] ìš”ì²­ ë³´ëƒ„ â†’', `DELETE ${API}/api/v1/folders/${folderId}`) if (!res.ok) { console.error('[handleDeleteFolder] í´ë” ì‚­ì œ ì‹¤íŒ¨:', res.status, await res.text()) return } console.log('[handleDeleteFolder] í´ë” ì‚­ì œ ì„±ê³µ:', folderId) // í´ë” ëª©ë¡ ë‹¤ì‹œ ë¡œë“œ await loadFolders() } catch (err) { console.error('[handleDeleteFolder] ì˜ˆì™¸ ë°œìƒ:', err) } } // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 7) ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸° // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ useEffect(() => { const handleClickOutside = (e) => { if (contextMenuRef.current && !contextMenuRef.current.contains(e.target)) { setFolderContextMenu({ visible: false, x: 0, y: 0, folderId: null }) setNoteContextMenu({ visible: false, x: 0, y: 0, noteId: null, folderId: null }) } } document.addEventListener('mousedown', handleClickOutside) return () => document.removeEventListener('mousedown', handleClickOutside) }, []) // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 8) íŠ¸ë¦¬ ë Œë”ë§: renderTree // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ const renderTree = (list) => list.map((node) => ( <li key={node.id}> <div className="folder-label" draggable onDragStart={(e) => { e.dataTransfer.setData('folderId', node.id) e.dataTransfer.setData('type', 'folder') console.log('[DragStart] folderId=', node.id, 'type=folder') }} onClick={() => { // â‘  í´ë” ì—´ê¸°/ë‹«ê¸° í† ê¸€ setOpenMap((prev) => ({ ...prev, [node.id]: !prev[node.id] })) // â‘¡ ë¶€ëª¨(Layout) ì»´í¬ë„ŒíŠ¸ì— ì„ íƒëœ í´ë” ID ì „ë‹¬ if (onSelectFolder) onSelectFolder(node.id) // â‘¢ URLì„ "/main/:folderId"ë¡œ ë³€ê²½ navigate(`/main/${node.id}`) }} onContextMenu={(e) => { e.preventDefault() // ë…¸íŠ¸ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ìˆ¨ê¸°ê¸° setNoteContextMenu({ visible: false, x: 0, y: 0, noteId: null, folderId: null }) // í´ë” ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í‘œì‹œ setFolderContextMenu({ visible: true, x: e.clientX, y: e.clientY, folderId: node.id }) }} onDrop={(e) => handleDrop(e, node.id)} onDragOver={(e) => e.preventDefault()} > <span>ğŸ“ {node.name}</span> </div> {openMap[node.id] && node.children.length > 0 && ( <ul className="folder-children">{renderTree(node.children)}</ul> )} {openMap[node.id] && node.notes.length > 0 && ( <ul className={`note-list ${node.parent_id ? 'nested' : 'root'}`}> {node.notes.map((n) => ( <li key={n.id} className="note-label" draggable onDragStart={(e) => { e.dataTransfer.setData('noteId', n.id) e.dataTransfer.setData('type', 'note') console.log('[DragStart] noteId=', n.id, 'type=note') }} onClick={() => { navigate(`/notes/${n.id}`) if (onNoteSelect) onNoteSelect(n.id) }} onContextMenu={(e) => { e.preventDefault() setFolderContextMenu({ visible: false, x: 0, y: 0, folderId: null }) setNoteContextMenu({ visible: true, x: e.clientX, y: e.clientY, noteId: n.id, folderId: node.id }) }} > ğŸ“ {n.title} </li> ))} </ul> )} </li> )) return ( <aside className="sidebar"> {/* â€“ ë¡œê³  ì˜ì—­ â€“ */} <div className="sidebar-logo" style={{ cursor: 'pointer' }} onClick={() => { if (onSelectFolder) onSelectFolder(null) navigate('/main') }} > <img src="/logo.png" alt="NoteFlow Logo" className="logo-icon" /> <span className="logo-text">NoteFlow</span> </div> <div className="sidebar-controls"> {/* ìµœê·¼ ë…¸íŠ¸ ë²„íŠ¼ */} <button className={activeFilter === 'recent' ? 'active' : ''} onClick={() => { setActiveFilter('recent') onFilterChange('recent') if (onSelectFolder) onSelectFolder(null) navigate('/main') }} > ìµœê·¼ ë…¸íŠ¸ </button> {/* ë‚´ í´ë” ì„¹ì…˜ */} <div className="folder-section"> <button className={activeFilter === 'all' ? 'active' : ''} onClick={() => { setActiveFilter('all') onFilterChange('all') if (onSelectFolder) onSelectFolder(null) navigate('/main') }} > ë‚´ í´ë” </button> {activeFilter === 'all' && ( <ul className="folder-list"> {treeFolders.length === 0 ? ( <li style={{ color: '#777', padding: '0.5rem 1rem' }}>í´ë”ê°€ ì—†ìŠµë‹ˆë‹¤.</li> ) : ( renderTree(treeFolders) )} </ul> )} </div> {/* ì¦ê²¨ì°¾ê¸° ë²„íŠ¼ */} <button className={activeFilter === 'favorites' ? 'active' : ''} onClick={() => { setActiveFilter('favorites') onFilterChange('favorites') if (onSelectFolder) onSelectFolder(null) navigate('/main') }} > ì¦ê²¨ì°¾ê¸° </button> </div> {/* í´ë” ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ */} {folderContextMenu.visible && ( <div className="context-menu" style={{ top: folderContextMenu.y, left: folderContextMenu.x, position: 'fixed', zIndex: 1000 }} ref={contextMenuRef} > <div onClick={() => { handleNewNote(folderContextMenu.folderId) setFolderContextMenu({ visible: false, x: 0, y: 0, folderId: null }) }}>â• ìƒˆ ë…¸íŠ¸</div> <div onClick={() => { handleNewFolder(folderContextMenu.folderId) setFolderContextMenu({ visible: false, x: 0, y: 0, folderId: null }) }}>â• ìƒˆ í´ë”</div> <div onClick={() => { handleRenameFolder(folderContextMenu.folderId) setFolderContextMenu({ visible: false, x: 0, y: 0, folderId: null }) }}>âœï¸ ì´ë¦„ ë³€ê²½</div> <div onClick={() => { handleDeleteFolder(folderContextMenu.folderId) setFolderContextMenu({ visible: false, x: 0, y: 0, folderId: null }) }}>ğŸ—‘ï¸ í´ë” ì‚­ì œ</div> </div> )} {/* ë…¸íŠ¸ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ */} {noteContextMenu.visible && ( <div className="context-menu" style={{ top: noteContextMenu.y, left: noteContextMenu.x, position: 'fixed', zIndex: 1000 }} ref={contextMenuRef} > <div onClick={() => { handleRenameNote(noteContextMenu.noteId, noteContextMenu.folderId) setNoteContextMenu({ visible: false, x: 0, y: 0, noteId: null, folderId: null }) }}>âœï¸ ì´ë¦„ ë³€ê²½</div> <div onClick={() => { handleDeleteNote(noteContextMenu.noteId) setNoteContextMenu({ visible: false, x: 0, y: 0, noteId: null, folderId: null }) }}>ğŸ—‘ï¸ ë…¸íŠ¸ ì‚­ì œ</div> </div> )} </aside> ) } // src/components/Topbar.jsx import React, { useState, useEffect, useRef } from 'react' import { useNavigate } from 'react-router-dom' import '../css/Topbar.css' export default function TopBar({ onNewNote, currentNote, onToggleFavorite }) { const [query, setQuery] = useState('') const [results, setResults] = useState([]) const [showSettings, setShowSettings] = useState(false) const btnRef = useRef(null) const navigate = useNavigate() useEffect(() => { const onClickOutside = e => { if (btnRef.current && !btnRef.current.contains(e.target)) { setShowSettings(false) } } document.addEventListener('mousedown', onClickOutside) return () => document.removeEventListener('mousedown', onClickOutside) }, []) useEffect(() => { if (!query.trim()) { setResults([]) return } fetch(`${import.meta.env.VITE_API_BASE_URL}/api/v1/notes`, { headers: { Authorization: `Bearer ${localStorage.getItem('access_token')}` } }) .then(res => res.ok ? res.json() : Promise.reject()) .then(data => { const filtered = data.filter(n => n.title.toLowerCase().includes(query.toLowerCase()) ) setResults(filtered) }) .catch(err => { console.error('ë…¸íŠ¸ ê²€ìƒ‰ ì‹¤íŒ¨:', err) }) }, [query]) return ( <header className="topbar"> <div className="topbar-left"> <button className="topbar-new" onClick={onNewNote}>+ ìƒˆ ë…¸íŠ¸</button> <div className="search-container"> <input className="topbar-search" type="text" placeholder="ğŸ” ë…¸íŠ¸ ì œëª© ê²€ìƒ‰" value={query} onChange={e => setQuery(e.target.value)} /> {results.length > 0 && ( <ul className="search-results"> {results.slice(0, 5).map(note => ( <li key={note.id} onClick={() => { navigate(`/notes/${note.id}`) setQuery('') setResults([]) }} > ğŸ“ {note.title} </li> ))} </ul> )} </div> </div> <div className="topbar-actions"> {currentNote && ( <button className="topbar-fav" onClick={onToggleFavorite} aria-label="ì¦ê²¨ì°¾ê¸°" > {currentNote.is_favorite ? 'â­' : 'â˜†'} </button> )} <button ref={btnRef} className="topbar-settings" onClick={() => setShowSettings(prev => !prev)} aria-label="ì„¤ì •" > â‹¯ </button> {showSettings && ( <div className="settings-menu"> <input className="settings-search" type="text" placeholder="ì‘ì—… ê²€ìƒ‰..." /> <div className="settings-item">ë§í¬ ë³µì‚¬</div> <div className="settings-item disabled">ì˜®ê¸°ê¸°</div> <div className="settings-item toggle"> ì‘ì€ í…ìŠ¤íŠ¸ <label className="switch"> <input type="checkbox" /> <span className="slider" /> </label> </div> </div> )} </div> </header> ) } // src/screen/KakaoCallback.jsx import { useEffect } from 'react'; import { useNavigate, useSearchParams } from 'react-router-dom'; export default function KakaoCallback() { const navigate = useNavigate(); const [searchParams] = useSearchParams(); useEffect(() => { const code = searchParams.get('code'); console.log('Kakao code:', code); if (!code) { alert('ì¹´ì¹´ì˜¤ ë¡œê·¸ì¸ ì‹¤íŒ¨: code ì—†ìŒ'); return; } fetch('http://222.116.135.71:8080/api/v1/auth/kakao/callback', { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded', }, body: new URLSearchParams({ code }), // âœ… form-encoded ë°©ì‹ }) .then((res) => res.json().then(data => ({ status: res.status, data }))) .then(({ status, data }) => { if (status === 200 && data.user_id && data.access_token) { localStorage.setItem('access_token', data.access_token); navigate('/main'); } else { alert(data.message || 'ì¹´ì¹´ì˜¤ ë¡œê·¸ì¸ ì‹¤íŒ¨'); } }) .catch(() => alert('ì„œë²„ ì—°ê²° ì‹¤íŒ¨')); }, [navigate, searchParams]); return <div>ì¹´ì¹´ì˜¤ ë¡œê·¸ì¸ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤...</div>; } import React, { useState, useRef } from 'react'; import { useNavigate } from 'react-router-dom'; import '../css/Login.css'; import { GoogleOAuthProvider, GoogleLogin } from '@react-oauth/google'; export default function LoginPage() { const navigate = useNavigate(); const [username, setUsername] = useState(''); const [password, setPassword] = useState(''); const googleLoginBtnRef = useRef(null); const handleLogin = async (e) => { e.preventDefault(); try { const response = await fetch(import.meta.env.VITE_API_BASE_URL + '/api/v1/login', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ loginId: username, password }) }); const data = await response.json(); if (response.ok) { localStorage.setItem('access_token', data.access_token); navigate('/main'); } else { alert(data.message || 'ë¡œê·¸ì¸ ì‹¤íŒ¨'); } } catch (err) { alert('ì„œë²„ì™€ì˜ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.'); } }; const handleSocialLogin = (provider) => { if (provider === 'google') { if (googleLoginBtnRef.current) { const googleButton = googleLoginBtnRef.current.querySelector('div[role="button"]'); if (googleButton) googleButton.click(); } } else if (provider === 'naver') { const clientId = import.meta.env.VITE_NAVER_CLIENT_ID; const redirectUri = import.meta.env.VITE_NAVER_REDIRECT_URI; const state = Math.random().toString(36).substring(2, 15); window.location.href = `https://nid.naver.com/oauth2.0/authorize?response_type=code&client_id=${clientId}&redirect_uri=${redirectUri}&state=${state}`; } else if (provider === 'kakao') { const kakaoClientId = import.meta.env.VITE_KAKAO_CLIENT_ID; const kakaoRedirectUri = 'http://localhost:5174/kakao/callback'; const kakaoAuthUrl = `https://kauth.kakao.com/oauth/authorize?client_id=${kakaoClientId}&redirect_uri=${kakaoRedirectUri}&response_type=code`; window.location.href = kakaoAuthUrl; } else { alert(`${provider} ë¡œê·¸ì¸ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`); } }; return ( <GoogleOAuthProvider clientId={import.meta.env.VITE_GOOGLE_CLIENT_ID}> <div className="login-container"> <div className="login-box"> <div className="login-logo-box"> <img src="/logo.png" alt="NoteFlow Logo" className="login-logo-img" /> <h1 className="login-logo-text">NoteFlow</h1> </div> <form className="login-form" onSubmit={handleLogin}> <input type="text" placeholder="ì•„ì´ë””" className="login-input" value={username} onChange={(e) => setUsername(e.target.value)} /> <input type="password" placeholder="ë¹„ë°€ë²ˆí˜¸" className="login-input" value={password} onChange={(e) => setPassword(e.target.value)} /> <button type="submit" className="login-btn">ë¡œê·¸ì¸</button> </form> <div className="login-social-login"> <button className="login-circle-btn login-kakao-btn"> <img src="/kakao-icon.svg" alt="Kakao" className="login-kakao-icon" onClick={() => handleSocialLogin('kakao')} /> </button> <button className="login-circle-btn login-naver-btn"> <img src="/naver-icon.png" alt="Naver" className="login-naver-icon" onClick={() => handleSocialLogin('naver')} /> </button> <button className="login-circle-btn login-google-btn"> <img src="/google-icon.svg" alt="Google" className="login-google-icon" onClick={() => handleSocialLogin('google')} /> </button> </div> <div style={{ position: 'absolute', left: '-9999px' }} ref={googleLoginBtnRef}> <GoogleLogin onSuccess={async (response) => { const token = response.credential; const res = await fetch(import.meta.env.VITE_API_BASE_URL + '/api/v1/login/google', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token }) }); const data = await res.json(); if (res.ok) { localStorage.setItem('access_token', data.access_token); navigate('/main'); } else { alert(data.message || 'êµ¬ê¸€ ë¡œê·¸ì¸ ì‹¤íŒ¨'); } }} onError={() => alert('êµ¬ê¸€ ë¡œê·¸ì¸ ì‹¤íŒ¨')} useOneTap={false} /> </div> <div className="login-signup-text"> ê³„ì •ì´ ì—†ìœ¼ì‹ ê°€ìš”?{' '} <a onClick={() => navigate('/signup')} style={{ cursor: 'pointer' }}> íšŒì›ê°€ì… </a> </div> </div> </div> </GoogleOAuthProvider> ); } // src/screen/Main.jsx import React, { useState, useEffect, useCallback } from 'react' import { useNavigate, useOutletContext, useParams } from 'react-router-dom' import '../css/Main.css' export default function MainPage() { const navigate = useNavigate() // URL íŒŒë¼ë¯¸í„° :folderId const { folderId } = useParams() const parsedFolderId = folderId ? parseInt(folderId, 10) : null // Layoutì—ì„œ ë‚´ë ¤ì¤€ context const { filter, // 'all' | 'recent' | 'favorites' fileUploadTimestamp, // ì—…ë¡œë“œ ì‹œë§ˆë‹¤ ê°±ì‹ ë˜ëŠ” timestamp } = useOutletContext() // ìƒíƒœ: ë…¸íŠ¸ ëª©ë¡, íŒŒì¼ ëª©ë¡, ê·¸ë¦¬ê³  í´ë”ëª… const [notes, setNotes] = useState([]) const [files, setFiles] = useState([]) const [folderName, setFolderName] = useState('') // ë“œë˜ê·¸ ì˜¤ë²„ ìƒíƒœ (trueë©´ ë°°ê²½ìƒ‰ ê°•ì¡°) const [isDragOver, setIsDragOver] = useState(false) const token = localStorage.getItem('access_token') const API = import.meta.env.VITE_API_BASE_URL // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 1) í´ë”ëª… ê°€ì ¸ì˜¤ê¸° (parsedFolderId ë³€ê²½ ì‹œ) // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ useEffect(() => { if (!parsedFolderId) { setFolderName('') return } fetch(`${API}/api/v1/folders`, { headers: { Authorization: `Bearer ${token}` } }) .then((res) => { if (!res.ok) throw new Error('í´ë” ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨') return res.json() }) .then((data) => { const found = data.find((f) => f.id === parsedFolderId) setFolderName(found ? found.name : '') }) .catch((err) => { console.error('í´ë”ëª… ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', err) setFolderName('') }) }, [parsedFolderId, API, token]) // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 2) ë…¸íŠ¸ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° (filter, parsedFolderId ë³€ê²½ ì‹œ) // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ useEffect(() => { if (!parsedFolderId) { let url = filter === 'recent' ? '/api/v1/notes/recent' : '/api/v1/notes' fetch(`${API}${url}`, { headers: { Authorization: `Bearer ${token}` } }) .then((res) => { if (!res.ok) throw new Error('ë…¸íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨') return res.json() }) .then((data) => { if (filter === 'favorites') { setNotes(data.filter((n) => n.is_favorite)) } else { setNotes(data) } }) .catch((err) => { console.error('ë…¸íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', err) setNotes([]) }) setFiles([]) } else { fetch(`${API}/api/v1/notes`, { headers: { Authorization: `Bearer ${token}` } }) .then((res) => { if (!res.ok) throw new Error('ë…¸íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨') return res.json() }) .then((data) => { const filteredNotes = data.filter((n) => n.folder_id === parsedFolderId) setNotes(filteredNotes) }) .catch((err) => { console.error('í´ë” ë‚´ ë…¸íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', err) setNotes([]) }) } }, [filter, parsedFolderId, API, token]) // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 3) íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° (parsedFolderId, fileUploadTimestamp ë³€ê²½ ì‹œ) // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ const fetchFiles = useCallback(() => { if (parsedFolderId !== null) { fetch(`${API}/api/v1/files/list/${parsedFolderId}`, { headers: { Authorization: `Bearer ${token}` } }) .then((res) => { if (!res.ok) throw new Error('íŒŒì¼ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨') return res.json() }) .then((data) => { setFiles(data) }) .catch((err) => { console.error('í´ë” ë‚´ íŒŒì¼ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', err) setFiles([]) }) } else { setFiles([]) } }, [parsedFolderId, API, token]) useEffect(() => { fetchFiles() }, [fetchFiles, fileUploadTimestamp]) // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 4) ë“œë˜ê·¸ ì•¤ ë“œë¡­: íŒŒì¼ ë“œë¡­ ì´ë²¤íŠ¸ ì²˜ë¦¬ + ì‹œê° í”¼ë“œë°± // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ const handleDragOver = (e) => { e.preventDefault() } const handleDragEnter = (e) => { e.preventDefault() setIsDragOver(true) } const handleDragLeave = (e) => { e.preventDefault() setIsDragOver(false) } const handleFileDrop = async (e) => { e.preventDefault() setIsDragOver(false) if (parsedFolderId === null) { alert('ë¨¼ì € ì—…ë¡œë“œí•  í´ë”ë¥¼ ì„ íƒí•˜ì„¸ìš”.') return } const droppedFiles = e.dataTransfer.files if (!droppedFiles || droppedFiles.length === 0) return for (let i = 0; i < droppedFiles.length; i++) { const file = droppedFiles[i] const formData = new FormData() formData.append('upload_file', file) formData.append('folder_id', parsedFolderId) console.log(`[handleFileDrop] íŒŒì¼ ì—…ë¡œë“œ ìš”ì²­ â†’ "${file.name}" â†’ í´ë” ${parsedFolderId}`) try { const res = await fetch(`${API}/api/v1/files/upload`, { method: 'POST', headers: { Authorization: `Bearer ${token}` }, body: formData }) if (!res.ok) { console.error(`[handleFileDrop] ì—…ë¡œë“œ ì‹¤íŒ¨: "${file.name}"`, res.status, await res.text()) } else { console.log(`[handleFileDrop] ì—…ë¡œë“œ ì„±ê³µ: "${file.name}"`) } } catch (err) { console.error(`[handleFileDrop] ì˜ˆì™¸ ë°œìƒ: "${file.name}"`, err) } } // ì—…ë¡œë“œ ì™„ë£Œ í›„ ì¦‰ì‹œ ëª©ë¡ ê°±ì‹  fetchFiles() } // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ // 5) í™”ë©´ ë Œë”ë§: í´ë” ì„ íƒ ì—¬ë¶€ì— ë”°ë¼ ë…¸íŠ¸ & íŒŒì¼ ë¶„ë¦¬ í‘œì‹œ // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ return ( <main className="main-content" style={{ padding: '1rem' }}> {/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */} {/* 5-1) parsedFolderIdê°€ null â†’ ì „ì²´/ìµœê·¼/ì¦ê²¨ì°¾ê¸° ë…¸íŠ¸ë§Œ í‘œì‹œ */} {/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */} {parsedFolderId === null && ( <section className="main-note-list"> {notes.map((note) => ( <div key={note.id} className="main-note-item" draggable onDragStart={(e) => { e.dataTransfer.setData('noteId', note.id) e.dataTransfer.setData('type', 'note') }} onClick={() => navigate(`/notes/${note.id}`)} > <h3 className="main-note-title">{note.title}</h3> <p className="main-note-preview"> {note.content?.slice(0, 100) || ''} </p> <span className="main-note-date"> {new Date(note.created_at).toLocaleDateString()} </span> </div> ))} </section> )} {/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */} {/* 5-2) parsedFolderIdê°€ ìˆ«ì â†’ í•´ë‹¹ í´ë” ID ë‚´ ë…¸íŠ¸ & íŒŒì¼ í‘œì‹œ */} {/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */} {parsedFolderId !== null && ( <> {/* 5-2-1) í—¤ë”: â€œğŸ“‚ {í´ë”ëª…}â€ */} <h2 style={{ fontSize: '1.5rem', marginBottom: '0.75rem' }}> ğŸ“‚ {folderName || `í´ë” #${parsedFolderId}`} </h2> {/* 5-2-2) í´ë” ë‚´ ë…¸íŠ¸ ì„¹ì…˜ */} <section className="main-note-list"> {notes.length === 0 ? ( <p style={{ color: '#777' }}>ì´ í´ë”ì—ëŠ” ë…¸íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</p> ) : ( notes.map((note) => ( <div key={note.id} className="main-note-item" draggable onDragStart={(e) => { e.dataTransfer.setData('noteId', note.id) e.dataTransfer.setData('type', 'note') }} onClick={() => navigate(`/notes/${note.id}`)} > <h3 className="main-note-title">{note.title}</h3> <p className="main-note-preview"> {note.content?.slice(0, 100) || ''} </p> <span className="main-note-date"> {new Date(note.created_at).toLocaleDateString()} </span> </div> )) )} </section> {/* 5-2-3) êµ¬ë¶„ì„  */} <hr style={{ margin: '1.5rem 0', borderColor: '#ddd' }} /> {/* 5-2-4) í´ë” ë‚´ íŒŒì¼ ì„¹ì…˜ (ë“œë˜ê·¸ ì•¤ ë“œë¡­ í—ˆìš©) */} <h3 style={{ marginBottom: '0.5rem' }}> ğŸ“ ì—…ë¡œë“œëœ íŒŒì¼ ({files.length}) </h3> <section className={`main-file-list ${` isDragOver ? 'drag-over' : '' }`}` onDragEnter={handleDragEnter} onDragOver={handleDragOver} onDragLeave={handleDragLeave} onDrop={handleFileDrop} style={{ minHeight: '150px' }} > {files.length === 0 ? ( <p style={{ color: '#777' }}>ì´ í´ë”ì—ëŠ” ì—…ë¡œë“œëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.</p> ) : ( <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}> {files.map((f) => ( <li key={f.file_id} className="main-file-item" onClick={() => { // í´ë¦­ ì‹œ ë¯¸ë¦¬ë³´ê¸°/ë‹¤ìš´ë¡œë“œ (ìƒˆ íƒ­) window.open( `${API}/api/v1/files/download/${f.file_id}`, '_blank' ) }} style={{ display: 'flex', alignItems: 'center', padding: '0.75rem', borderBottom: '1px solid #e8e8e8', cursor: 'pointer', transition: 'background 0.15s ease', }} onMouseEnter={(e) => (e.currentTarget.style.background = '#f9f9f9')} onMouseLeave={(e) => (e.currentTarget.style.background = 'transparent')} > {/* ê°„ë‹¨í•œ íŒŒì¼ ì•„ì´ì½˜ */} <div style={{ width: '32px', height: '32px', background: '#f0f0f0', borderRadius: '4px', display: 'flex', alignItems: 'center', justifyContent: 'center', marginRight: '0.75rem', fontSize: '1.2rem', }} > ğŸ“„ </div> <div style={{ display: 'flex', flexDirection: 'column' }}> <span style={{ fontSize: '1rem', color: '#333' }}> {f.original_name} </span> <span style={{ fontSize: '0.85rem', color: '#555' }}> {new Date(f.created_at).toLocaleDateString()} </span> </div> </li> ))} </ul> )} {/* <div style={{ textAlign: 'center', color: '#999', marginTop: '1rem' }}> íŒŒì¼ì„ ì´ ì˜ì—­ìœ¼ë¡œ ë“œë˜ê·¸ ì•¤ ë“œë¡­í•˜ë©´ ë°”ë¡œ ì—…ë¡œë“œë©ë‹ˆë‹¤. </div> */} </section> </> )} </main> ) } // src/screen/NaverCallback.jsx import { useEffect } from 'react'; import { useNavigate, useSearchParams } from 'react-router-dom'; export default function NaverCallback() { const navigate = useNavigate(); const [searchParams] = useSearchParams(); useEffect(() => { const code = searchParams.get('code'); const state = searchParams.get('state'); if (code && state) { fetch('http://222.116.135.71:8080/api/v1/login/naver', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ code, state }), }) .then((res) => res.json()) .then((data) => { if (data.user_id) { navigate('/main'); } else { alert(data.message || 'ë„¤ì´ë²„ ë¡œê·¸ì¸ ì‹¤íŒ¨'); } }) .catch(() => alert('ì„œë²„ ì—°ê²° ì‹¤íŒ¨')); } }, [navigate, searchParams]); return <div>ë„¤ì´ë²„ ë¡œê·¸ì¸ ì²˜ë¦¬ ì¤‘...</div>; } import React, { useState } from 'react' import { useNavigate } from 'react-router-dom' import '../css/NewNote.css' export default function NewNotePage() { const navigate = useNavigate() const [title, setTitle] = useState('') const [content, setContent] = useState('') const handleSave = async (e) => { e.preventDefault() try { const res = await fetch( `${import.meta.env.VITE_API_BASE_URL}/api/v1/notes`, { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${localStorage.getItem('access_token')}` }, body: JSON.stringify({ title, content }) } ) if (res.ok) navigate('/main') else { const { detail } = await res.json() alert(detail || 'ë…¸íŠ¸ ìƒì„± ì‹¤íŒ¨') } } catch { alert('ì„œë²„ ì—°ê²° ì‹¤íŒ¨') } } return ( <div className="newnote-container"> <form className="newnote-form" onSubmit={handleSave}> <input type="text" placeholder="ì œëª©" value={title} onChange={e => setTitle(e.target.value)} className="newnote-title" /> <textarea placeholder="ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”" value={content} onChange={e => setContent(e.target.value)} className="newnote-content" /> <div className="newnote-actions"> <button type="submit" className="newnote-save-btn">ì €ì¥</button> <button type="button" className="newnote-cancel-btn" onClick={() => navigate('/main')} > ì·¨ì†Œ </button> </div> </form> </div> ) } // src/screen/NoteDetail.jsx import React, { useState, useEffect, useRef } from 'react' import { useParams, useNavigate, useOutletContext } from 'react-router-dom' import { Editor } from '@toast-ui/react-editor' import '@toast-ui/editor/dist/toastui-editor.css' export default function NoteDetail() { const { id } = useParams() const navigate = useNavigate() const editorRef = useRef() const [note, setNote] = useState(null) const [saving, setSaving] = useState(false) const [summarizing, setSummarizing] = useState(false) const { setCurrentNote } = useOutletContext() // ì—…ë¡œë“œëœ íŒŒì¼ ëª©ë¡ ìƒíƒœ const [files, setFiles] = useState([]) // ë¯¸ë¦¬ë³´ê¸° ìƒíƒœ (URL, MIME íƒ€ì…, íŒŒì¼ëª…) const [previewUrl, setPreviewUrl] = useState(null) const [previewType, setPreviewType] = useState(null) const [previewName, setPreviewName] = useState(null) const token = localStorage.getItem('access_token') // 1) ë…¸íŠ¸ ë°ì´í„° ë¡œë“œ useEffect(() => { fetch(`${import.meta.env.VITE_API_BASE_URL}/api/v1/notes/${id}`, { headers: { Authorization: `Bearer ${token}` } }) .then(res => (res.ok ? res.json() : Promise.reject())) .then(data => { setNote(data) setCurrentNote(data) }) .catch(() => { alert('ë…¸íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.') navigate('/main') }) }, [id, navigate, setCurrentNote, token]) // 2) ì—…ë¡œë“œëœ íŒŒì¼ ëª©ë¡ ë¡œë“œ useEffect(() => { if (!note) return const folderId = note.folder_id if (!folderId) { setFiles([]) return } fetch(`${import.meta.env.VITE_API_BASE_URL}/api/v1/files/list/${folderId}`, { headers: { Authorization: `Bearer ${token}` } }) .then(res => (res.ok ? res.json() : Promise.reject())) .then(data => { setFiles(data) }) .catch(() => { console.error('íŒŒì¼ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.') setFiles([]) }) }, [note, token]) // 3) typeWriter í•¨ìˆ˜ function typeWriter(editorRef, fullText, speed = 25, done = () => {}) { const inst = editorRef.current?.getInstance() if (!inst) return let i = 0 inst.setMarkdown('') inst.focus() const step = () => { i += 1 inst.setMarkdown(fullText.slice(0, i)) if (i < fullText.length) { setTimeout(step, speed) } else { done() } } step() } if (!note) return null // 4) ë…¸íŠ¸ ì €ì¥ í•¸ë“¤ëŸ¬ const handleSave = async () => { const content = editorRef.current.getInstance().getMarkdown() setSaving(true) try { const res = await fetch( `${import.meta.env.VITE_API_BASE_URL}/api/v1/notes/${id}`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ title: note.title, content, folder_id: note.folder_id }) } ) if (!res.ok) throw new Error('Save failed') const updated = await res.json() setNote(updated) setCurrentNote(updated) alert('ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.') } catch { alert('ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.') } finally { setSaving(false) } } // 5) ë…¸íŠ¸ ìš”ì•½ í•¸ë“¤ëŸ¬ const handleSummarize = async () => { setSummarizing(true) try { const res = await fetch( `${import.meta.env.VITE_API_BASE_URL}/api/v1/notes/${id}/summarize`, { method: 'POST', headers: { Authorization: `Bearer ${token}` } } ) if (!res.ok) throw new Error('Summarize failed') const updated = await res.json() setNote(updated) setCurrentNote(updated) setTimeout(() => { typeWriter(editorRef, updated.content ?? '', 20, () => setSummarizing(false)) }, 150) } catch { alert('ìš”ì•½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.') setSummarizing(false) } } // 6) íŒŒì¼ í´ë¦­ ì‹œ ë¯¸ë¦¬ë³´ê¸° í•¸ë“¤ëŸ¬ const handleFileClick = async (file_id, original_name, content_type) => { try { // ì¸ì¦ ì—†ì´ ì—´ë¦¬ëŠ” ì—”ë“œí¬ì¸íŠ¸ í˜¸ì¶œ const res = await fetch( `${import.meta.env.VITE_API_BASE_URL}/api/v1/files/download/${file_id}` ) if (!res.ok) { console.error('íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨', res.status, await res.text()) return } const blob = await res.blob() const url = window.URL.createObjectURL(blob) setPreviewUrl(url) setPreviewType(content_type) setPreviewName(original_name) } catch (err) { console.error('ë¯¸ë¦¬ë³´ê¸° ì¤‘ ì˜ˆì™¸', err) } } // 7) ë¯¸ë¦¬ë³´ê¸° ë‹«ê¸° const closePreview = () => { if (previewUrl) window.URL.revokeObjectURL(previewUrl) setPreviewUrl(null) setPreviewType(null) setPreviewName(null) } return ( <div className="main-container"> <main className="main-content" style={{ padding: '1rem' }}> {/* ë…¸íŠ¸ ì œëª© + ë²„íŠ¼ */} <div style={{ display: 'flex', alignItems: 'center', gap: '1rem', marginBottom: '1rem' }} > <h1 style={{ flex: 1, fontSize: '1.5rem', margin: 0 }}> {note.title} </h1> <button onClick={handleSave} disabled={saving} style={{ padding: '0.6rem 1.2rem', background: saving ? '#ccc' : '#007aff', color: '#fff', border: 'none', borderRadius: '0.4rem' }} > {saving ? 'ì €ì¥ì¤‘â€¦' : 'ğŸ’¾ ì €ì¥'} </button> <button onClick={handleSummarize} disabled={summarizing} style={{ padding: '0.6rem 1.2rem', background: summarizing ? '#ccc' : '#28a745', color: '#fff', border: 'none', borderRadius: '0.4rem' }} > {summarizing ? 'ìš”ì•½ì¤‘â€¦' : 'ğŸ§  ìš”ì•½'} </button> </div> {/* í† ìŠ¤íŠ¸UI ì—ë””í„° */} <Editor key={id} ref={editorRef} initialValue={note.content ?? ''} previewStyle="vertical" height="600px" initialEditType="markdown" useCommandShortcut={true} /> {/* ì—…ë¡œë“œëœ íŒŒì¼ ëª©ë¡ */} <div style={{ marginTop: '2rem' }}> <h3 style={{ marginBottom: '0.5rem' }}> ğŸ—‚ï¸ ì—…ë¡œë“œëœ íŒŒì¼ ({files.length}) </h3> <ul style={{ listStyle: 'none', paddingLeft: 0, margin: 0 }}> {files.map(f => ( <li key={f.file_id} style={{ display: 'flex', flexDirection: 'column', padding: '0.75rem 1rem', marginBottom: '0.5rem', background: '#f9f9f9', borderRadius: '0.4rem', cursor: 'pointer', transition: 'background 0.2s' }} onClick={() => handleFileClick(f.file_id, f.original_name, f.content_type) } onMouseOver={e => (e.currentTarget.style.background = '#eef')} onMouseOut={e => (e.currentTarget.style.background = '#f9f9f9')} > <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}> {/* íŒŒì¼ ì•„ì´ì½˜ */} <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#555" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" > <path d="M14 2H6a2 2 0 0 0-2 2v16c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V8z" /> <polyline points="14 2 14 8 20 8" /> </svg> <span style={{ fontSize: '1rem', color: '#333' }}> {f.original_name} </span> </div> <small style={{ color: '#777', marginTop: '0.25rem' }}> {new Date(f.created_at).toLocaleString()} </small> </li> ))} </ul> </div> {/* ë¯¸ë¦¬ë³´ê¸° ëª¨ë‹¬ (ë‹¤ìš´ë¡œë“œ ê¸°ëŠ¥ ì—†ìŒ) */} {previewUrl && ( <div style={{ position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh', background: 'rgba(0, 0, 0, 0.6)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }} onClick={closePreview} > <div style={{ position: 'relative', width: '80%', maxWidth: '900px', height: '80%', background: '#fff', borderRadius: '0.4rem', overflow: 'hidden', boxShadow: '0 2px 10px rgba(0,0,0,0.3)' }} onClick={e => e.stopPropagation()} > {/* ë‹«ê¸° ë²„íŠ¼ */} <button onClick={closePreview} style={{ position: 'absolute', top: '0.5rem', right: '0.5rem', background: 'transparent', border: 'none', fontSize: '1.5rem', cursor: 'pointer' }} > Ã— </button> {/* ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° */} {previewType.startsWith('image/') && ( <img src={previewUrl} alt={previewName} style={{ width: '100%', height: '100%', objectFit: 'contain', background: '#000' }} /> )} {/* PDF ë¯¸ë¦¬ë³´ê¸° */} {previewType === 'application/pdf' && ( <iframe src={previewUrl} title={previewName} style={{ width: '100%', height: '100%', border: 'none' }} /> )} {/* ê·¸ ì™¸ íŒŒì¼: ë¯¸ë¦¬ë³´ê¸° ì—†ìŒ ë©”ì‹œì§€ */} {!previewType.startsWith('image/') && previewType !== 'application/pdf' && ( <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', flexDirection: 'column', padding: '1rem', textAlign: 'center' }} > <p style={{ color: '#333' }}> ë¯¸ë¦¬ë³´ê¸°ë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤. </p> </div> )} </div> </div> )} </main> </div> ) } // src/screen/Signup.jsx import React, { useState } from 'react' import '../css/Signup.css' import { useNavigate } from 'react-router-dom' export default function SignupPage() { const navigate = useNavigate() const [loginId, setLoginId] = useState('') const [password, setPassword] = useState('') const [confirmPw, setConfirmPw] = useState('') const [email, setEmail] = useState('') const handleSignup = async (e) => { e.preventDefault() if (password !== confirmPw) { alert('ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤') return } try { const res = await fetch( `${import.meta.env.VITE_API_BASE_URL}/api/v1/register`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ loginId, email, password }) } ) const data = await res.json() if (res.ok) { navigate('/') } else { alert(data.detail || data.message || 'íšŒì›ê°€ì… ì‹¤íŒ¨') } } catch { alert('ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.') } } return ( <div className="signup-container"> <div className="signup-box"> <div className="signup-logo-box"> <img src="/logo.png" alt="NoteFlow Logo" className="signup-logo-img" /> <h1 className="signup-logo-text">NoteFlow</h1> </div> <form className="signup-form" onSubmit={handleSignup}> <input type="text" placeholder="ì•„ì´ë””" className="signup-input" value={loginId} onChange={e => setLoginId(e.target.value)} /> <input type="password" placeholder="ë¹„ë°€ë²ˆí˜¸" className="signup-input" value={password} onChange={e => setPassword(e.target.value)} /> <input type="password" placeholder="ë¹„ë°€ë²ˆí˜¸ í™•ì¸" className="signup-input" value={confirmPw} onChange={e => setConfirmPw(e.target.value)} /> <input type="email" placeholder="ì´ë©”ì¼" className="signup-input" value={email} onChange={e => setEmail(e.target.value)} /> <button type="submit" className="signup-signup-btn"> íšŒì›ê°€ì… </button> </form> <div className="signup-social-login"> <button className="signup-circle-btn signup-kakao-btn"> <img src="/kakao-icon.svg" alt="Kakao" className="signup-kakao-icon" /> </button> <button className="signup-circle-btn signup-naver-btn"> <img src="/naver-icon.png" alt="Naver" className="signup-naver-icon" /> </button> <button className="signup-circle-btn signup-google-btn"> <img src="/google-icon.svg" alt="Google" className="signup-google-icon" /> </button> </div> <div className="signup-login-text"> ì´ë¯¸ ê³„ì •ì´ ìˆìœ¼ì‹ ê°€ìš”?{' '} <span className="signup-login-link" onClick={() => navigate('/')} > ë¡œê·¸ì¸ </span> </div> </div> </div> ) } // src/App.tsx import React from 'react' import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom' import LoginPage from './screen/Login' import SignupPage from './screen/Signup' import MainPage from './screen/Main' import Layout from './components/Layout' import NewNotePage from './screen/NewNotePage' import NoteDetail from './screen/NoteDetail' import NaverCallback from './screen/NaverCallback' import KakaoCallback from './screen/KakaoCallback' import './App.css' const App: React.FC = () => ( <BrowserRouter> <Routes> {/* --- ì¸ì¦ ê´€ë ¨ (ë¡œê·¸ì¸/íšŒì›ê°€ì…/ì†Œì…œ ì½œë°±) --- */} <Route path="/" element={<LoginPage />} /> <Route path="/signup" element={<SignupPage />} /> <Route path="/naver/callback" element={<NaverCallback />} /> <Route path="/kakao/callback" element={<KakaoCallback />} /> {/* --- Layout í•˜ìœ„ ë¼ìš°íŒ… --- */} <Route element={<Layout />}> {/* 1) í´ë” ë¯¸ì„ íƒ(ì „ì²´/ìµœê·¼/ì¦ê²¨ì°¾ê¸°) */} <Route path="/main" element={<MainPage />} /> {/* 2) í´ë” ì„ íƒ ìƒíƒœ (URLì— folderIdê°€ ë¶™ìŒ) */} <Route path="/main/:folderId" element={<MainPage />} /> {/* ìƒˆ ë…¸íŠ¸ ìƒì„± */} <Route path="/notes/new" element={<NewNotePage />} /> {/* ë…¸íŠ¸ ìƒì„¸ ë³´ê¸° */} <Route path="/notes/:id" element={<NoteDetail />} /> </Route> {/* --- ê·¸ ì™¸ ëª¨ë“  ê²½ë¡œëŠ” ë¡œê·¸ì¸ìœ¼ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸ --- */} <Route path="*" element={<Navigate to="/" replace />} /> </Routes> </BrowserRouter> ) export default App import React from 'react'; import ReactDOM from 'react-dom/client'; import App from './App'; import { GoogleOAuthProvider } from '@react-oauth/google'; const rootElement = document.getElementById('root'); if (!rootElement) throw new Error("root element not found"); ReactDOM.createRoot(rootElement).render( <GoogleOAuthProvider clientId={import.meta.env.VITE_GOOGLE_CLIENT_ID}> <React.StrictMode> <App /> </React.StrictMode> </GoogleOAuthProvider> );

###### ChatGPTì˜ ë§:

Something went wrong, please try reloading the conversation.

  

ChatGPTëŠ” ì‹¤ìˆ˜ë¥¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. OpenAIì—ì„œëŠ” AIì•¼ìƒë™ë¬¼í–‰ë™ìƒíƒœì œì–´ê¸°ì´ˆì—°êµ¬ì‹¤ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ë°ì´í„°ë¥¼ ì´ìš©í•´ ëª¨ë¸ì„ í›ˆë ¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.