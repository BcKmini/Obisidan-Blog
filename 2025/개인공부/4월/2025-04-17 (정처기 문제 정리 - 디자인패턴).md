시나공 문제풀이 
C, JAVA, 키워드찾기 100![[스크린샷 2025-04-17 21.34.03.png]]
![[스크린샷 2025-04-17 21.39.16.png]]![[스크린샷 2025-04-17 23.03.46.png]]

#### **. 디자인패턴**

-좋은코드(객체간 응집도는 높이고, 결합도는 낮게 해 요구사항 변경 시 코드변경 최소화)를 설계하기 위한 설계방법론

-반복적으로 나타나는 문제들을 해결해 온 전문가들의 경험을 모아서 정리한 일관된 솔루션 -> 생산성향상, 표준화

-수행목적에 따라 생성패턴, 구조패턴, 행위패턴으로 구분
ㅡ
-GoF '바퀴를 다시 개발하지 마라'

#### **2. 디자인패턴 - 생성패턴(5개) ->  팩토리메서드, 싱글톤, 추상팩토리, 빌더, 프로토타입**

- 객체 인스턴스 생성을 위한 클래스 정의와 객체새성방식의 구조화, 캡슐화 방법 제공

(1) Factory Method(팩토리메서드)

: 객체생성을 위한 인터페이스를 따로 정의, 객체를 생성하는 일을 서브클래스가 담당하도록 하는 패턴

(2) SingleTone(싱글톤)

: 지정한 클래스의 인스턴스가 반드시 한개만 존재하도록 하는 패턴

(3) Abstract Factory(추상팩토리)

 : 구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독집적인 객체들의 집합을 생 성할 수 있는 인터페이스를 제공하는 패턴

(4) Builder(빌더) 

 : 복잡한 객체를 생성하는 방법과 표현하는 방법을 정의하는 클래스를 별도로 분리해 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공하는 패턴

(5) Prototype(프로토타입)

 : 원본이 되는 인스턴스를 사용하여 생성할 객체의 종류를 명시하고 견본을 복하새허 새로운 객체를 생성하는 패턴 

#### **3. 디자인패턴 - 구조패턴(7개) -> 어댑터, 브릿지, 컴포지트, 데코레이터, 퍼싸드, 플라이웨이트, 프록시**

- 다른 기능을 가진 객체간에 협력이 필요할 때 객체들을 조직화하는 방법과 기능을 구현하기 위해 객체를 구성하는 방식을 제공

(1) Adapter(어댑터)

 : 클래스의 재사용성을 높이기 위해 클래스간의 기능을 변환제공하여 호환성을 확보하는 패턴

(2) Bridge(브릿지)

 : 인터페이스(API)가 서로다른 클래스를 연결하는 패턴으로 기능의 계층과 구현의 계층을 연결시키는 패턴

(3) Composite(컴포지트)

 : 복잡한 객체구조를 표현하여 객체집합 속에 또 다른 객체집합을 갖는 패턴

(4) 데코레이터(Decorator)

 : 새로운 기능이 추가될 때마다 새로운 객체를 만들고, 이전 객체의 기능은 새로운 객체내에서도 그대로 유지, 보장해주는 패턴

(5) 퍼싸드(Facade)

 : 서브시스템이 복잡할 경우 간단한 인터페이스를 통해 서브시스템의 주요기능을 사용할 수 있는 패턴

(6) 플라이웨이트(Fly weight)

 : 인스턴스를 가능한 한 공유시켜 불필요한 생성을 하지않도록 하는 패턴

(7) 프록시(Proxy)

 : 객체접근을 제어하려는 목적으로 인터페이스 역할을 하는 객체를 사용하여 제어하는 패턴

#### **4. 디자인패턴 - 행위패턴(11개) -> 템플릿 메소드, 인터프리터, 반복자, 커맨드, 책임연쇄, 상태, 전략, 중재자, 메멘토, 방문자, 옵저버**  

- 객체간의 기능을 분배하는 일과 같은 로직 수행에 주로 이용하여 객체간 연동에 대한 유형을 제공

(1) 템플릿메소드(Template method)

 : 상위클래스에서 처리의 흐름을 정하고 하위클래스에서 구체적인 내용을 재정의

(2) 인터프리터(Interpreter)

 : 간단한 언어의 문법을 정의하는 방법과 그 언어로 문장을 구성하는 방법, 문장을 해석하는 방법을 제시하는 패턴

(3) 반복자(Iterator)

 : 접근이 잦은객테에 대해 동일 인터페이스를 사용하도록 하는 패턴, 집합객체 요소들의 내부표현 방식을 공개하지 않고, 순차적으로 접근하는 구조를 제공

(4) 커맨드(Command)

 : 요청자체를 객체화(캡슐화)하고 매개변수(파라미터)를 추가하여 여러가지 요구사항을 추가할 수 있는패턴

(5) 책임연쇄(Chain of Responsibility)

 : 요청을 처리할 수 있는 기회를 하나 이상의 객체에 부여함으로써 객체간의 결합도를 없애려는 패턴, 각 객체들이 고리로 묶여있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감

(6) 상태(State)

 : 상태를 일반적인 데이터 변수로 두지 않고 객체로 만들어 그 상태에 따른 행동들을 분리한 패턴

(7) 전략(Strategy)

 : 상황에 따라 알고리즘을 변화할 필요가 있을 때 , 각 알고리즘 클래스들을 공통된 인터페이스에 맞게 구현하여 다형성을 활용하는 패턴

(8) 중재자(Mediator)

 : 중재자를 통해 한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 패턴

(9) 메멘토(Memento)

 : 어떤 시점에서의 객체상태를 저장해두었다가 필요시 객체를 그 시점의 상태로 되돌리는 패턴

(10) 방문자(Visitor)

 : 데이터구조안을 돌아다니는 주체인 '방문자(Observer)'를 나타내는 클래스를 준비해서 그 클래스에게 처리를 맡김으로서 처리기능 분리

(11) 옵저버(Observer)

 : 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 통지되고 필요시 자동으로 내용이 갱신되는 패턴