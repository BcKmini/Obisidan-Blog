## 자주 사용하는 O-표기
| 표기             | 한국어 명칭   | 영어 명칭            | 간단 설명                       |
| -------------- | -------- | ---------------- | --------------------------- |
| **O(1)**       | 상수 시간    | Constant time    | 입력 크기와 무관하게 일정한 시간 소요       |
| **O(log n)**   | 로그 시간    | Logarithmic time | 크기가 n인 입력을 로그 단위로 줄여가며 처리   |
| **O(n)**       | 선형 시간    | Linear time      | 입력 크기에 비례하여 시간 증가           |
| **O(n log n)** | 로그 선형 시간 | Log-linear time  | 선형과 로그가 혼합된 복합적인 증가         |
| **O(n²)**      | 이차 시간    | Quadratic time   | n×n 만큼의 연산이 필요한 경우          |
| **O(n³)**      | 3차 시간    | Cubic time       | n×n×n 만큼의 연산이 필요한 경우        |
| **O(n^k)**     | 다항식 시간   | Polynomial time  | k는 상수, n^k 형태로 시간 증가        |
| **O(2^n)**     | 지수 시간    | Exponential time | 입력 크기에 따라 연산량이 2의 거듭제곱으로 폭증 |
### O-표기의 포함 관계

| 표현                | 빅오 표기        | 간단 설명                         |
| ----------------- | ------------ | ----------------------------- |
| 14, 1000          | **O(1)**     | 상수 시간. 입력 크기와 무관하게 일정한 시간 소요  |
| 3 log n + 6       | **O(log n)** | 로그 시간. n이 커질수록 로그 단위로 증가      |
| 5n + 4            | **O(n)**     | 선형 시간. n에 비례하여 증가             |
| 2n² + 10n + 3     | **O(n²)**    | 이차 시간. n² 항이 주도               |
| n³ + n² - 10n + 3 | **O(n³)**    | 3차 시간. n³ 항이 주도               |
| 2ⁿ                | **O(2ⁿ)**    | 지수 시간. 입력 크기에 따라 2의 거듭제곱으로 폭증 |

![[스크린샷 2025-03-18 10.43.58.png]]


---
## 점화식과 알고리즘 
- 많은 알고리즘의 비용함수는 점화식 형태로 주어짐
- 📌 점화식
  -  어떤 함수를 자신보다 저 작은 변수값에 대한 함수와의 관계로 표현한 것
$$
\begin{aligned}
a_n &= a_{n-1} + 2 \\
f(n) &= n \cdot f(n-1) \\
f(n) &= f(n-1) + f(n-2) \\
f(n) &= f\left(\frac{n}{2}\right) + 1
\end{aligned}
$$

![[스크린샷 2025-03-18 10.55.01.png]]

---
### 점화식의 점근적 분석방법
- 반복대치
  - 더 작은 문제에 대한 함수로 반복해서 대치해 나가는 해법
- 추정 후 증명
  - 결론을 추정하고 수학적 귀납벅으로 이용하여 증명하는 방법
- 마스터 정리
  - 형식에 맞는 점화식의 복잡도를 바로 알 수 있다.

## 반복 대치
![[스크린샷 2025-03-18 10.58.16.png]]![[스크린샷 2025-03-18 10.58.32.png]]

---
##  추정후 증명
![[스크린샷 2025-03-18 11.16.00.png]]
![[스크린샷 2025-03-18 11.16.10.png]]![[스크린샷 2025-03-18 11.16.17.png]]

---
## 마스터 정리Master Theorem
![[스크린샷 2025-03-18 11.21.48.png]]

- 1. **h(n)** 이 더 무거우면 **h(n)** 이 수행시간을 결정한다.
- 2. **f(n)** 이 더 무거우면 **f(n)** 이 수행시간을 결정한다.
- 3. **h(n)** 과 **f(n)** 이 같은 무게이면 **h(n)** 에 **logN** 을 곱한것이 수행시간이 된다.
#### 📌 예시
![[스크린샷 2025-03-18 11.25.51.png]]

---
## 📌 요약
## 알고리즘(Algorithm)이란?

- **정의**: 문제를 해결하기 위한 단계적 절차 또는 방법
- **의사코드(pseudo code)** 형태로 주로 표현

---
## 알고리즘의 일반적 특성

- **정확성**: 주어진 입력에 대해 올바른 해를 제시해야 함
- **수행성**: 각 단계는 컴퓨터에서 실제로 수행 가능해야 함
- **유한성**: 유한 시간 내에 종료되어야 함
- **효율성**: 효율적일수록(시간·공간 자원) 가치가 높음

---
## 알고리즘 효율성: 시간 복잡도(Time Complexity)

- **시간 복잡도**: 알고리즘이 수행하는 연산(주로 기본 연산) 횟수를 입력 크기에 대한 함수로 표현
- **복잡도 분석**:
    - **최악 경우(Worst case)**: 가장 오래 걸리는 경우
    - **평균 경우(Average case)**: 평균적으로 걸리는 경우
    - **최선 경우(Best case)**: 가장 빠른 경우

---
## 점근적 표기(Asymptotic Notation)

- **입력 크기 n**이 무한대로 커질 때의 알고리즘 복잡도를 간단히 표현하기 위한 표기법
- **주요 표기**
    - **O(Big-Oh)**: 점근적 상한(Upper bound)
    - **Ω(Big-Omega)**: 점근적 하한(Lower bound)
    - **Θ(Big-Theta)**: 동일한 증가율(Tight bound)

---
### 정리
- 알고리즘은 문제 해결을 위한 체계적인 절차
- 효율성(시간 복잡도)이 핵심 척도
- 점근적 표기를 통해 복잡도를 단순화하여 표현
- 최악·평균·최선 경우 분석으로 알고리즘 성능을 비교