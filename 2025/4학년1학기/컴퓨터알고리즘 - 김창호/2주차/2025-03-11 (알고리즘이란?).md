.ssh/known.hosts -> key 충돌 

## 이진탐색 실습
```c
#include <stdio.h>

int bsearch(int arr[], int key, int beg, int end);
int main()
{
int a[] = {10, 20, 25, 35, 45, 55, 60, 75, 80, 90, 95};

	int beg = 0, end, mid, key;
	key = 55; // 주석 다는 부분 key 값
	end = sizeof(a) / sizeof(int);
	
	scanf("%d", &key);
	mid = bsearch(a, key, beg, end);
	if (mid == -1)
		printf("%d is not found\n", key);
	else
		printf("A[%d] = %d\n", mid, a[mid]);
}

int bsearch (int arr[], int key, int beg, int end)
{
	int mid=(beg+end)/2;
	if (end-beg <= 1)
		return arr[mid] == key ? mid : -1;
	if(key < arr[mid])
		return bsearch(arr, key, beg, mid);
	else
		return bsearch(arr, key, mid, end);

}
```

## 과제
## 가짜동전문제 개선

주교재에서 가짜 동전을 찾는 알고리즘을 소개하였다.  이 보다 더 빠르게 찾는 방법을 찾아 보고자 한다.

1. 광수의 아이디어에 따라 3개의 동전 중 가짜 동전을 찾을 때 몇 번에 찾을 수 있는가?
2. 광수의 아이디어에 따라, 만약  9개의 동전에서 교재에서 제시한 방법으로 가짜 동전을 찾는다면 최악의 경우 몇 번에 찾을 수 있는가?
3. 광수의 아이디어를 변형하여 9개를 3개씩 3등분하여 찾는 방법으로 바꾸면 몇 번에  찾을 수 있겠는가?
4. 90개의 동전에서 1개의 가짜 동전을 찾는 방법을 교재의 방법(광수의 아이디어)으로 찾을 때 몇 번에 찾을 수 있는가?
5. 90개의 동전을 3등분하는 방법으로 찾으면 몇 번에 찾을 수 있는가?

> 코드 구현

---

# 📌 1장 알고리즘이란?
## 알고리즘
- 문제를 해결하는 단계적 절차 또는 방법
- 여기서 주어지는 문제는 컴퓨터를 이용하여 해결
- 알고리즘에는 입력이 주어지고, 알고리즘은 수행한 결과인 해 (또는 답)를 출력한다.
### 알고리즘의 일반적 특성
정확성
- 알고리즘은 주어진 입력에 대해 올바른 해를 주어야(랜덤 알고리즘은 예외)한다.
수행성
- 알고리즘의 각 단계는 컴퓨터에서 수행 가능해야한다.
유한성
- 알고리즘은 유한 시간 내에 종료되어야 한다.
효율성
- 알고리즘은 효율적일수록 그 가치가 높아진다.
## 최초의 알고리즘 - 유클리드
유클리드(Euclid)의 최대공약수 알고리즘
- 기원전 300년경에 만들어짐
- 최대공약수란 2개의 자연수의 공약수들 중에서 큰 수 

> 2개의 자연수의 최대공약수는 큰 수에서 작은 수를 뺀 수와 작은 수와의 최대공약수와 같다.

