## 1. 함수 선언 (fun)
- 코틀린에서 함수는 `fun` 키워드를 사용하여 선언합니다.

### 함수의 기본 구조
```
fun 함수이름(인자이름: 인자타입): 반환타입 {
    // 함수 본문
    return 반환값
}
```

- **함수이름**: 함수를 호출할 때 사용하는 이름입니다.
- **인자 (Parameter)**: 함수가 작업을 수행하는 데 필요한 값으로, `이름: 타입` 형식으로 선언합니다.
- **반환타입**: 함수가 작업을 마치고 반환하는 값의 타입입니다.
- 함수가 아무것도 반환하지 않을 경우, 반환 타입을 생략하거나 `Unit`을 명시할 수 있습니다. `Unit`은 자바의 `void`와 유사하지만 실제로는 객체입니다.

### 예제

```
// 두 정수를 더하고 결과를 반환하는 함수
fun add(a: Int, b: Int): Int {
    return a + b
}

// 아무것도 반환하지 않는 함수 (반환 타입 Unit은 생략 가능)
fun printMessage(message: String) { // : Unit 생략됨
    println(message)
}

fun main() {
    val sum = add(5, 3)
    println("5 + 3 = $sum") // 출력: 5 + 3 = 8
    
    printMessage("Hello, Kotlin!") // 출력: Hello, Kotlin!
}
```

---
## 2. 기본 인자(Default Parameter)와 이름 붙은 인자(Named Argument)
코틀린은 함수의 호출을 더 유연하고 명확하게 만들어주는 두 가지 편리한 기능을 제공합니다.

### 기본 인자값 (Default Parameters)
- 함수를 정의할 때 인자에 기본값을 설정할 수 있습니다. 함수를 호출할 때 해당 인자 값을 생략하면 설정된 기본값이 사용됩니다.
    

#### 예제
```
fun greet(name: String, greeting: String = "Hello") {
    println("$greeting, $name!")
}

fun main() {
    greet("Alice") // greeting 인자 생략, 기본값 "Hello" 사용
    greet("Bob", "Hi") // greeting 인자 값 지정, "Hi" 사용
}
/* 출력:
Hello, Alice!
Hi, Bob!
*/
```

### 이름 붙은 인자 (Named Arguments)
- 함수를 호출할 때 인자 이름을 명시하여 값을 전달하는 방식입니다. 이를 통해 코드의 가독성을 높일 수 있으며, 인자의 순서를 지키지 않고도 값을 전달할 수 있습니다.
- 특히 기본 인자값과 함께 사용하면 특정 인자만 값을 변경하고 싶을 때 매우 유용합니다.
    

#### 예제
```
fun buildUserProfile(name: String, age: Int, city: String = "Seoul") {
    println("이름: $name, 나이: $age, 도시: $city")
}

fun main() {
    // 순서에 상관없이 인자 이름을 명시하여 전달
    buildUserProfile(age = 30, name = "Charlie", city = "Busan")
    
    // 기본 인자값과 함께 사용 (city는 기본값 "Seoul" 사용)
    buildUserProfile(name = "David", age = 25)
}
/*
출력:
이름: Charlie, 나이: 30, 도시: Busan
이름: David, 나이: 25, 도시: Seoul
*/
```

----
## 3. 단일 표현식 함수 (Single-Expression Functions)
- 함수 본문이 단일 표현식으로 이루어져 있다면, 중괄호 `{}`와 `return` 키워드를 생략하고 등호 `=`를 사용하여 함수를 간결하게 정의할 수 있습니다.
- 코틀린의 타입 추론 기능 덕분에 대부분의 경우 반환 타입도 생략이 가능합니다.
    

### 예제
```
// 일반적인 함수 정의
fun maxOf(a: Int, b: Int): Int {
    return if (a > b) a else b
}

// 단일 표현식 함수로 변환 (반환 타입 Int 추론 가능)
fun maxOfSimple(a: Int, b: Int) = if (a > b) a else b

// 두 숫자를 더하는 단일 표현식 함수
fun sum(a: Int, b: Int) = a + b

fun main() {
    println("Max is: ${maxOfSimple(10, 20)}") // 출력: Max is: 20
    println("Sum is: ${sum(5, 7)}")      // 출력: Sum is: 12
}
```

---
## 4. 고차 함수 (Higher-Order Functions)와 람다 표현식 (Lambda Expressions)

코틀린에서는 함수를 값처럼 다룰 수 있으며, 이는 함수형 프로그래밍의 핵심적인 특징입니다.
- **고차 함수 (Higher-Order Functions)**: 다른 함수를 인자로 받거나, 함수를 결과로 반환하는 함수를 의미합니다.
- **람다 표현식 (Lambda Expressions)**: 이름이 없는 익명 함수로, 주로 고차 함수에 인자로 전달될 때 사용되며 `{ ... }` 형태로 작성됩니다.
    

### 고차 함수와 람다의 활용
함수 타입은 `(매개변수 타입) -> 반환 타입` 형태로 선언합니다.
```
// 고차 함수 정의: (Int) -> Int 타입의 함수를 인자로 받음
fun processNumber(number: Int, operation: (Int) -> Int) {
    val result = operation(number) // 전달받은 함수를 호출
    println(result)
}

fun main() {
    // 람다 표현식을 고차 함수에 전달
    processNumber(10, { num -> num * 2 }) // 출력: 20
    processNumber(10, { num -> num + 5 }) // 출력: 15
}
```

### 람다 표현식의 간결한 문법
코틀린은 람다를 더 간결하게 작성할 수 있도록 다양한 문법을 제공합니다.
1. **it 키워드**: 람다의 매개변수가 하나뿐일 경우, `it`이라는 암시적 이름을 사용하여 파라미터 선언을 생략할 수 있습니다.
    ```
    val numbers = listOf(1, 2, 3, 4, 5)
    // 매개변수가 하나이므로 'it'을 사용하여 짝수만 필터링
    val evens = numbers.filter { it % 2 == 0 } 
    println(evens) // 출력: [2, 4]
    ```
2. **후행 람다 (Trailing Lambda)**: 함수의 마지막 인자가 람다일 경우, 소괄호 `()` 밖으로 람다를 뺄 수 있습니다. 이는 코드의 가독성을 크게 향상시킵니다.
    ```
    val numbers = listOf(1, 2, 3)
    
    // 일반적인 호출
    numbers.forEach({ println(it) })
    // 후행 람다 적용
    numbers.forEach { println(it) }
    ```
    
### 실용적인 고차 함수와 람다 응용
코틀린 표준 라이브러리는 `filter`, `map`, `forEach` 등 데이터 처리를 위한 수많은 고차 함수를 제공합니다. 이는 개발자가 '어떻게(how)' 데이터를 처리할지가 아닌, **'무엇을(what)'** 할지에 집중하게 하여 코드의 의도를 명확하게 드러냅니다.

---
#### 명령형 방식 vs 함수형 방식
```
val numbers = listOf(-3, 1, -5, 2, 0, 4)

// 1. 명령형 방식: for 루프와 if 조건문 사용
val positiveNumbersImperative = mutableListOf<Int>()
for (num in numbers) {
    if (num > 0) {
        positiveNumbersImperative.add(num)
    }
}
println(positiveNumbersImperative) // 출력: [1, 2, 4]

// 2. 함수형 방식: filter 고차 함수 사용
val positiveNumbersFunctional = numbers.filter { it > 0 }
println(positiveNumbersFunctional) // 출력: [1, 2, 4]
```

---
### 주요 고차 함수 표

|   |   |   |   |   |
|---|---|---|---|---|
|**함수명**|**역할**|**람다 형태**|**예제 코드**|**결과**|
|**filter**|조건을 만족하는 요소로 이루어진 새 리스트 반환|`(T) -> Boolean`|`listOf(1,2,3).filter { it > 1 }`|`[2, 3]`|
|**map**|각 요소에 변환 함수를 적용한 새 리스트 반환|`(T) -> R`|`listOf(1,2,3).map { it * 10 }`|`[10, 20, 30]`|
|**forEach**|각 요소에 대해 주어진 작업을 수행|`(T) -> Unit`|`listOf("A","B").forEach { println(it) }`|`A` `B`|
|**find**|조건을 만족하는 첫 번째 요소 반환 (없으면 null)|`(T) -> Boolean`|`listOf(1,2,3).find { it % 2 == 0 }`|`2`|
|**any**|조건을 만족하는 요소가 하나라도 있는지 확인|`(T) -> Boolean`|`listOf(1,2,3).any { it > 2 }`|`true`|
|**count**|조건을 만족하는 요소의 개수 반환|`(T) -> Boolean`|`listOf(1, 2, 3, 4).count { it % 2 == 0}`|`2`|